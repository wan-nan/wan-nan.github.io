<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#0078E7"><meta name="author" content="wan_nan"><meta name="copyright" content="wan_nan"><meta name="generator" content="Hexo 5.4.0"><meta name="theme" content="hexo-theme-yun"><title>文献阅读 | 风物</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/star-markdown-css@0.1.25/dist/yun/yun-markdown.min.css"><script src="//at.alicdn.com/t/font_1140697_dxory92pb0h.js" async></script><script src="https://cdn.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>document.addEventListener("DOMContentLoaded", () => {
  [".post-card",".post-content img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
});
</script><link class="aplayer-style-marker" rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script class="aplayer-script-marker" src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" defer></script><script class="meting-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/pjax@latest/pjax.min.js" defer></script><script src="/js/pjax.js" defer></script><script src="https://cdn.jsdelivr.net/npm/vue@2.6.11"></script><link rel="icon" href="/dino.png"><link rel="mask-icon" href="/dino.png" color="#0078E7"><link rel="alternate icon" href="/yun.ico"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="preload" href="/js/utils.js" as="script"><link rel="preload" href="/js/hexo-theme-yun.js" as="script"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><script id="yun-config">
    const Yun = window.Yun || {};
    window.CONFIG = {"hostname":"wan-nan.github.io","root":"/","title":"风物的小站","version":"1.6.1","mode":"auto","copycode":true,"page":{"isPost":true},"i18n":{"placeholder":"搜索...","empty":"找不到您查询的内容: ${query}","hits":"找到 ${hits} 条结果","hits_time":"找到 ${hits} 条结果（用时 ${time} 毫秒）"},"anonymous_image":"https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/avatar/none.jpg","say":{"api":"https://el-bot-api.vercel.app/api/words/young"},"fireworks":{"colors":["102, 167, 221","62, 131, 225","33, 78, 194"]}};
  </script><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script src="/js/utils.js"></script><script src="/js/hexo-theme-yun.js"></script><link rel="preconnect" href="https://www.google-analytics.com" crossorigin><script async src="https://www.googletagmanager.com/gtag/js?id=G-1LL0D86CY9"></script><script>if (CONFIG.hostname === location.hostname) {
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-1LL0D86CY9');
}</script><script>//- only for pjax
function sendPageView() {
  if (CONFIG.hostname !== location.hostname) return;
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('event', 'page_view', {
    page_path: encodeURIComponent(location.pathname),
  })
}
document.addEventListener("pjax:success", sendPageView);</script><script data-ad-client="ca-pub-2245427233262012" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(function(){
  var bp = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  if (curProtocol === 'https') {
    bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else {
    bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(bp, s);
})();</script><!-- Google Tag Manager --><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src='https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','GTM-M9KWR9L');</script><!-- End Google Tag Manager --><meta name="description" content="Glossary   abbr. full name note    RDMA Remote Direct Memory Access    RoCE RDMA over Converged Ethernet    PFC Priority-based Flow Control    HOL blocking Head-of-Line blocking 队头阻塞   HPC High Perfor">
<meta property="og:type" content="article">
<meta property="og:title" content="文献阅读">
<meta property="og:url" content="https://wan-nan.github.io/2023/07/08/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/index.html">
<meta property="og:site_name" content="风物">
<meta property="og:description" content="Glossary   abbr. full name note    RDMA Remote Direct Memory Access    RoCE RDMA over Converged Ethernet    PFC Priority-based Flow Control    HOL blocking Head-of-Line blocking 队头阻塞   HPC High Perfor">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://wan-nan.github.io/2023/07/08/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/image-20230708193752784.png">
<meta property="og:image" content="https://wan-nan.github.io/2023/07/08/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/image-20230708200431834.png">
<meta property="og:image" content="https://wan-nan.github.io/2023/07/08/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/image-20230708200534078.png">
<meta property="og:image" content="https://wan-nan.github.io/2023/07/08/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/image-20230708200214455.png">
<meta property="og:image" content="https://wan-nan.github.io/2023/07/08/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/j8GaGaQE_dfdSPhc34X27TzDxE3j65Ca">
<meta property="og:image" content="https://wan-nan.github.io/2023/07/08/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/image-20230725172322605.png">
<meta property="og:image" content="https://wan-nan.github.io/2023/07/08/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/WA8@COU2%7BLX%60RUC27Y%601UV8.png">
<meta property="og:image" content="https://wan-nan.github.io/2023/07/08/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/image-20230725165753511.png">
<meta property="og:image" content="https://wan-nan.github.io/2023/07/08/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/image-20230725180254555.png">
<meta property="og:image" content="https://wan-nan.github.io/2023/07/08/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/image-20230802222336780.png">
<meta property="og:image" content="https://wan-nan.github.io/2023/07/08/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/image-20230811171105109.png">
<meta property="article:published_time" content="2023-07-08T11:10:10.000Z">
<meta property="article:modified_time" content="2023-08-19T08:06:16.728Z">
<meta property="article:author" content="wan_nan">
<meta property="article:tag" content="学习">
<meta property="article:tag" content="计算机网络">
<meta property="article:tag" content="research">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://wan-nan.github.io/2023/07/08/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/image-20230708193752784.png"><script src="/js/ui/mode.js"></script></head><body><script defer src="https://cdn.jsdelivr.net/npm/animejs@latest"></script><script defer src="/js/ui/fireworks.js"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/js/sidebar.js"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="文章目录"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-list-ordered"></use></svg></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="站点概览"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-passport-line"></use></svg></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about/" title="wan_nan"><img width="96" loading="lazy" src="/images/avatar.jpg" alt="wan_nan"><span class="site-author-status" title="sleeping">😴</span></a><div class="site-author-name"><a href="/about/">wan_nan</a></div><span class="site-name">风物</span><sub class="site-subtitle">Yeah!</sub><div class="site-desciption">个人博客</div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="首页"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-home-4-line"></use></svg></span></a><div class="site-state-item"><a href="/archives/" title="归档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-archive-line"></use></svg></span><span class="site-state-item-count">55</span></a></div><div class="site-state-item"><a href="/categories/" title="分类"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-2-line"></use></svg></span><span class="site-state-item-count">3</span></a></div><div class="site-state-item"><a href="/tags/" title="标签"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="site-state-item-count">40</span></a></div><a class="site-state-item hty-icon-button" href="/about/#comment" title="留言板"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-clipboard-line"></use></svg></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="http://wpa.qq.com/msgrd?v=3&amp;uin=2213324970&amp;site=qq&amp;menu=yes" title="QQ" target="_blank" style="color:#12B7F5"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-qq-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/wan-nan" title="GitHub" target="_blank" style="color:#181717"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-github-line"></use></svg></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-contrast-2-line"></use></svg></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Glossary"><span class="toc-number">1.</span> <span class="toc-text">Glossary</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CC"><span class="toc-number">2.</span> <span class="toc-text">CC</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#DCTCP-Data-center-tcp"><span class="toc-number">2.1.</span> <span class="toc-text">(DCTCP)Data center tcp</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#motivation"><span class="toc-number">2.1.1.</span> <span class="toc-text">motivation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Algorithm"><span class="toc-number">2.1.2.</span> <span class="toc-text">Algorithm</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Analysis"><span class="toc-number">2.1.3.</span> <span class="toc-text">Analysis</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DCQCN-Congestion-Control-for-Large-Scale-RDMA-Deployments"><span class="toc-number">2.2.</span> <span class="toc-text">(DCQCN) Congestion Control for Large-Scale RDMA Deployments</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#why-RDMA-need-drop-free-network"><span class="toc-number">2.2.1.</span> <span class="toc-text">why RDMA need drop-free network?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#limitations-of-PFC"><span class="toc-number">2.2.2.</span> <span class="toc-text">limitations of PFC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Algorithm-1"><span class="toc-number">2.2.3.</span> <span class="toc-text">Algorithm</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#note"><span class="toc-number">2.2.4.</span> <span class="toc-text">note</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TIMELY-RTT-based-Congestion-Control-for-the-Datacenter"><span class="toc-number">2.3.</span> <span class="toc-text">TIMELY: RTT-based Congestion Control for the Datacenter</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Abstract"><span class="toc-number">2.3.1.</span> <span class="toc-text">Abstract</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Background"><span class="toc-number">2.3.2.</span> <span class="toc-text">Background</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TIMELY-FRAMEWORK"><span class="toc-number">2.3.3.</span> <span class="toc-text">TIMELY FRAMEWORK</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RTT-Measurement-Engine"><span class="toc-number">2.3.3.1.</span> <span class="toc-text">RTT Measurement Engine</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Rate-Computation-Engine"><span class="toc-number">2.3.3.2.</span> <span class="toc-text">Rate Computation Engine</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Rate-Control-Engine"><span class="toc-number">2.3.3.3.</span> <span class="toc-text">Rate Control Engine</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TIMELY-CONGESTION-CONTROL"><span class="toc-number">2.3.4.</span> <span class="toc-text">TIMELY CONGESTION CONTROL</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Metrics-and-Setting"><span class="toc-number">2.3.4.1.</span> <span class="toc-text">Metrics and Setting</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Delay-Gradient-Approach"><span class="toc-number">2.3.4.2.</span> <span class="toc-text">Delay Gradient Approach</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#The-Main-Algorithm"><span class="toc-number">2.3.4.3.</span> <span class="toc-text">The Main Algorithm</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Gradient-versus-Queue-Size"><span class="toc-number">2.3.4.4.</span> <span class="toc-text">Gradient versus Queue Size</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IMPLEMENTATION"><span class="toc-number">2.3.5.</span> <span class="toc-text">IMPLEMENTATION</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Swift-Delay-is-Simple-and-Effective-for-Congestion-Control-in-the-Datacenter"><span class="toc-number">2.4.</span> <span class="toc-text">Swift: Delay is Simple and Effective for Congestion Control in the Datacenter</span></a></li></ol></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="hty-card post-block" itemscope itemtype="https://schema.org/Article"><link itemprop="mainEntityOfPage" href="https://wan-nan.github.io/2023/07/08/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="wan_nan"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="风物"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">文献阅读</h1><div class="post-meta"><div class="post-time" style="display:block"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-line"></use></svg></span> <time title="创建时间：2023-07-08 19:10:10" itemprop="dateCreated datePublished" datetime="2023-07-08T19:10:10+08:00">2023-07-08</time><span class="post-meta-divider">-</span><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-2-line"></use></svg></span> <time title="修改时间：2023-08-19 16:06:16" itemprop="dateModified" datetime="2023-08-19T16:06:16+08:00">2023-08-19</time></div><span class="post-count"><span class="post-symbolcount"><span class="post-meta-item-icon" title="本文字数"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-file-word-line"></use></svg></span> <span title="本文字数">4.4k</span><span class="post-meta-divider">-</span><span class="post-meta-item-icon" title="阅读时长"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-timer-line"></use></svg></span> <span title="阅读时长">21m</span></span></span><span class="post-busuanzi"><span class="post-meta-divider">-</span><span class="post-meta-item-icon" title="阅读次数"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-eye-line"></use></svg> <span id="busuanzi_value_page_pv"></span></span></span><div class="post-classify"><span class="post-category"> <span class="post-meta-item-icon" style="margin-right:3px;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-line"></use></svg></span><span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a class="category-item" href="/categories/%E7%AC%94%E8%AE%B0/" style="--text-color:dimgray" itemprop="url" rel="index"><span itemprop="text">笔记</span></a></span></span><span class="post-tag"><span class="post-meta-divider">-</span><a class="tag-item" href="/tags/%E5%AD%A6%E4%B9%A0/" style="--text-color:saddlebrown"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">学习</span></a><a class="tag-item" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">计算机网络</span></a><a class="tag-item" href="/tags/research/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">research</span></a></span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body" style="--smc-primary:#0078E7;"><h1 id="Glossary"><a href="#Glossary" class="headerlink" title="Glossary"></a>Glossary</h1><table>
<thead>
<tr>
<th align="center"><em>abbr.</em></th>
<th align="center"><em>full name</em></th>
<th align="center"><em>note</em></th>
</tr>
</thead>
<tbody><tr>
<td align="center">RDMA</td>
<td align="center">Remote Direct Memory Access</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">RoCE</td>
<td align="center">RDMA over Converged Ethernet</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">PFC</td>
<td align="center">Priority-based Flow Control</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">HOL blocking</td>
<td align="center">Head-of-Line blocking</td>
<td align="center"><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/330300133">队头阻塞</a></td>
</tr>
<tr>
<td align="center">HPC</td>
<td align="center">High Performance Computing</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">ToR</td>
<td align="center">Top of Rack</td>
<td align="center">架顶式(<em>ToR</em>)是一种常见的交换机到服务器连接架构</td>
</tr>
<tr>
<td align="center">NVM</td>
<td align="center">Non-Volatile Memory</td>
<td align="center">非易失性存储<br>NVM和RDMA可以称得上加速数据中心应用的两架马车<br>分别从存储和网络方面满足高带宽、低延迟的需求</td>
</tr>
<tr>
<td align="center">ECMP</td>
<td align="center">Equal-Cost Multi-Path routing</td>
<td align="center">等价多路径路由<br><a target="_blank" rel="noopener" href="https://www.sdnlab.com/20605.html">数据中心内负载均衡-ECMP的使用分析</a></td>
</tr>
<tr>
<td align="center">FCoE</td>
<td align="center">Fibre Channel over Ethernet</td>
<td align="center"><a target="_blank" rel="noopener" href="https://www.cnblogs.com/pipci/p/15352967.html">存储网络 – 了解FCoE的八个技术细节</a></td>
</tr>
<tr>
<td align="center">RED</td>
<td align="center">Random Early Detection</td>
<td align="center">旨在将队列的<strong>平均长度</strong>保持在较低的值，同时允许一定量的突发报文</td>
</tr>
<tr>
<td align="center">IOPS</td>
<td align="center">Input/Output Per Second</td>
<td align="center">衡量存储介质性能的主要指标之一<br>IOPS是指每秒钟系统能处理的读写请求数量</td>
</tr>
<tr>
<td align="center">MMU</td>
<td align="center">memory management unit</td>
<td align="center"><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/542960003">交换机buffer</a></td>
</tr>
<tr>
<td align="center">MTU</td>
<td align="center">Maximum Transmission Unit</td>
<td align="center"><a target="_blank" rel="noopener" href="https://info.support.huawei.com/info-finder/encyclopedia/zh/MTU.html">什么是MTU（Maximum Transmission Unit）？</a></td>
</tr>
<tr>
<td align="center">INT</td>
<td align="center">in-network telemetry</td>
<td align="center">HPCC用的</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<h1 id="CC"><a href="#CC" class="headerlink" title="CC"></a>CC</h1><p>DCTCP是window-based CC</p>
<p>DCQCN和TIMELY都是rate-based CC</p>
<h2 id="DCTCP-Data-center-tcp"><a href="#DCTCP-Data-center-tcp" class="headerlink" title="(DCTCP)Data center tcp"></a>(DCTCP)Data center tcp</h2><blockquote>
<p>该读$$\S3.4\ Guidelines\ for\ choosing\ parameters$$了，基本了解了数据中心的通信结构、负载组成、传统TCP在数据中心的不足及其成因；DCTCP算法流程、效果、数学推导。</p>
<p>后面基本是参数设置和实验环节</p>
</blockquote>
<h3 id="motivation"><a href="#motivation" class="headerlink" title="motivation"></a>motivation</h3><p>“(the soft real-time application) generate a diverse mix of short and long ﬂows, and require three things from the data center network: slow latency for short ﬂows, high burst tolerance, and high utilization for long ﬂows.”</p>
<p>“to meet the requirements of such a diverse mix of short and long flows, switch buffer occupancies need to be persistently low, while maintaining high throughput for the long flows.”</p>
<p>“DCTCP is designed to do exactly this.”</p>
<h3 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h3><p>算法分为三部分：</p>
<ol>
<li><p><strong>Simple Marking at the Switch:</strong> </p>
<p><strong>交换机</strong>按照阈值k来标记数据包，交换机的队列长度大于k时，交换机会在数据包的在IP报头中打上CE(Congestion Experienced)标记</p>
<p>与RED算法不同的是，DCTCP的标记based on instantaneous, instead of average queue length.</p>
</li>
<li><p><strong>ECN-Echo at the Receiver:</strong></p>
<blockquote>
<p>The only difference between a DCTCP receiver and a TCP receiver is </p>
<p>the way information in the CE codepoints is conveyed back to the sender.</p>
</blockquote>
<p><strong>接收端</strong>如何确定是否回复ECN-Echo(ECE)？考虑到Delayed ACKs，Receiver的行为遵循下面的FSM：</p>
<p>如果当前数据包中的CE标志与前一个不同，则接收方立即发送ACK。 当CE标志不变时，它会像正常的Delayed ACK一样。</p>
<img src="/2023/07/08/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/image-20230708193752784.png" alt="image-20230708193752784" style="zoom:67%;" loading="lazy">

<p>The states correspond to whether <strong>the last received packet</strong> was marked with the CE codepoint or not.</p>
</li>
<li><p><strong>Controller at the Sender:</strong></p>
<p><strong>发送端</strong>如何对ECE做出反应？</p>
<p>发送端计算【收到的数据包中被标记ECE的比例】，称为α，对于每个数据窗口（大约一个RTT）更新一次，计算公式如下所示：<br>$$<br>\alpha ← (1 − g) \times \alpha + g \times F<br>$$<br> exponential moving average——移动指数平均值</p>
<p>其中$$F$$是在最近的一个窗口中被标记ECE的包的比例，$$0&lt;g&lt;1$$是在$$\alpha$$的估计中给新样本与过去样本的权重。 </p>
<p>α估计队列大小大于K的概率。本质上，α接近0表示低拥塞，α接近1表示高拥塞水平。</p>
<blockquote>
<p>The only difference between a DCTCP sender and a TCP sender is </p>
<p>in how each reacts to receiving an ACK with the ECN-Echo flag set.</p>
</blockquote>
<p>DCTCP保留了TCP中的慢启动、拥塞避免中的Additive increase、丢包后的Recovery，不同之处在于对ECE的反应：<br>$$<br>cwnd ← cwnd \times (1 − \alpha/2)<br>$$</p>
</li>
</ol>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><ul>
<li><p>计算队列长度的式子：<br>$$<br>Q(t) = NW(t) −C \times RTT<br>$$</p>
<blockquote>
<p>We consider N infinitely long-lived flows with identical round-trip times RTT, sharing a single bottleneck link of capacity C.</p>
<p>We further assume that the N flows are synchronized; i.e., their “sawtooth” window dynamics are in-phase. Of course, this assumption is only realistic when N is small.</p>
<p>C应该就是BandWidth（？）C×RTT就是BDP</p>
</blockquote>
</li>
<li><p>锯齿形波动的振幅：振幅越小，队列长度保持的越稳定，CC性能越好</p>
<p>The most important of these is the <strong>amplitude of oscillations</strong>, which quantifies how well DCTCP is able to maintain steady queues, due to its gentle proportionate reaction to congestion indications.</p>
<img src="/2023/07/08/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/image-20230708200431834.png" alt="image-20230708200431834" style="zoom:50%;" loading="lazy">

<p>上图中TCP和DCTCP的差异在于下面的计算：</p>
<img src="/2023/07/08/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/image-20230708200534078.png" alt="image-20230708200534078" style="zoom:67%;" loading="lazy">

<p>TCP的amplitude的数量级是$$O(C\times RTT)$$，而DCTCP的amplitude只有 $$O(\sqrt{C\times RTT})$$</p>
<img src="/2023/07/08/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/image-20230708200214455.png" alt="image-20230708200214455" style="zoom: 67%;" loading="lazy"></li>
</ul>
<h2 id="DCQCN-Congestion-Control-for-Large-Scale-RDMA-Deployments"><a href="#DCQCN-Congestion-Control-for-Large-Scale-RDMA-Deployments" class="headerlink" title="(DCQCN) Congestion Control for Large-Scale RDMA Deployments"></a>(DCQCN) Congestion Control for Large-Scale RDMA Deployments</h2><blockquote>
<p>该读$$\S5.\ ANALYSIS\ OF\ DCQCN$$了，基本了解了RDMA在网络领域的背景知识，以及DCQCN的算法设计</p>
<p>后面基本是流体模型、参数设置和实验环节</p>
</blockquote>
<p>（本论文参考这个翻译读了不少）还不错的翻译：<a target="_blank" rel="noopener" href="https://ngdcn.com/post/91.html">【SIGCOMM 2015】出道即是巅峰！DCQCN：数据中心大规模部署RDMA的拥塞控制方案</a></p>
<h3 id="why-RDMA-need-drop-free-network"><a href="#why-RDMA-need-drop-free-network" class="headerlink" title="why RDMA need drop-free network?"></a>why RDMA need drop-free network?</h3><p>【为什么RDMA需要无损网络支持？】</p>
<p>在IP路由的数据中心网络上，RDMA使用RoCEv2协议进行部署，RoCEv2依赖PFC来实现无损网络（drop-free network）。</p>
<blockquote>
<p><strong><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/257228128">RDMA 在数据中心的可靠传输</a></strong></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/bandaoyu/article/details/115346857">【RDMA】无损网络和PFC</a></p>
<ul>
<li><p>比较尴尬的是，RDMA对丢包率的要求极高。0.1%的丢包率，将导致RDMA吞吐率急剧下降。2%的丢包率，将使得RDMA的吞吐率下降为0</p>
<img src="/2023/07/08/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/j8GaGaQE_dfdSPhc34X27TzDxE3j65Ca" alt=" 图源：鲜枣课堂" style="zoom:50%;" loading="lazy"></li>
<li><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/longbowchi/p/14802046.html">容损网络vs无损网络，讨论RDMA网络的两种思路</a></p>
<p>讨论了RDMA在容损网络和无损网络两种思路的发展历程，还举了近期的例子来说明，如</p>
<ul>
<li><p>基于容损网络的SIGCOMM2018：Revisiting Network Support for RDMA ：</p>
<p>SIGCOMM2018会议上，提出了IRN（Improved RoCE NIC）算法。该设计仍然保留<strong>“选择性重传”</strong>（允许丢包重传，所以是容损） 这一设计思路，作者认为iWarp的思路大方向正确，但是TCP协议对于智能网卡太过复杂，需要简化。截至今年（2021年），该设计仍处于实验室阶段，没有经过任何生产环境的考验。</p>
</li>
<li><p>基于无损网络的SIGCOMM2019：High Precision Congestion Control（HPCC）</p>
</li>
</ul>
</li>
</ul>
</blockquote>
<p>最开始RDMA技术是基于InfiniBand的，数据包丢失在此类群集中很少见，因此RDMA Infiniband传输层（在NIC上实现）的重传机制很简陋，即：go-back-N重传，但是现在RDMA的使用更广泛，在其他网络中（如基于以太网的RoCE网络），丢包的概率大于Infiniband集群，一旦丢包，使用RDMA的go-back-N重传机制效率非常低，会大大降低RDMA的传输效率，所以要想发挥出RDMA真正的性能，势必要为RDMA搭建一套不丢包的无损网络环境</p>
<p>早期的经验表明，RoCE NIC只有在不丢包网络上运行时才能取得良好的端到端性能（因为RoCE使用的是go-back-N重传，丢包后果很严重），因此运营商转向以太网优先级流控（PFC）机制</p>
<h3 id="limitations-of-PFC"><a href="#limitations-of-PFC" class="headerlink" title="limitations of PFC"></a>limitations of PFC</h3><p>【PFC的限制】</p>
<p>PFC(Priority-based Flow Control)是一种粗粒度的机制。其PAUSE机制进行流控的粒度是<strong>端口（或端口加优先级）</strong>的级别，而没有细化到flow的级别。因此PFC会导致<strong>head-of-line blocking (victim flow</strong>), <strong>unfairness</strong>和<strong>congestion-spreading</strong>等问题。</p>
<blockquote>
<p>我的理解是：PFC的PAUSE机制会ban掉一整条ingress（或该ingress中的某个优先级）上的所有flow</p>
<p>那么什么是基于flow的呢？flow可以理解成ip五元组：&lt;协议类型、源IP地址、目的IP地址、源端口号、目的端口号&gt;，对于TCP来讲就是一条TCP链接。但是一条连接中也可以有多条flow</p>
<p>所以DCQCN、DCTCP乃至TCP这种端到端的CC都可以理解成基于flow的<strong>（？）</strong></p>
</blockquote>
<blockquote>
<ul>
<li>ingress和egress：<ul>
<li><strong>Ingress</strong> - This is used to describe the port where a frame enters the device.</li>
<li><strong>Egress</strong> - This is used to describe the port that frames will use when leaving the device.</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="Algorithm-1"><a href="#Algorithm-1" class="headerlink" title="Algorithm"></a>Algorithm</h3><p>分为三部分：</p>
<blockquote>
<p>The DCQCN algorithm consists of the sender (<strong>reaction point (RP)</strong>), the switch (<strong>congestion point (CP)</strong>), and the receiver, (<strong>notification point (NP)</strong>).</p>
</blockquote>
<p>CP Algorithm: 与DCTCP类似，在egress queue中设置threshold并打上ECN标记</p>
<p>NP Algorithm: 按照一定的规则，生成Congestion Notification Packets (CNP)提醒拥塞发生</p>
<p>RP Algorithm: 按照状态机，对CNP做出反应，控制发送速率</p>
<img src="/2023/07/08/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/image-20230725172322605.png" alt="image-20230725172322605" style="zoom:67%;" loading="lazy">

<h3 id="note"><a href="#note" class="headerlink" title="note"></a>note</h3><p>【注释】</p>
<p><strong>PFC</strong>（Priority based Flow Control）是在交换机<strong>入口（ingress port）</strong>发起的拥塞管理机制。在通常无拥塞情况下，交换机的入口 buffer 不需要存储数据。当交换机出口（egress port）的 buffer 达到一定的阈值时，交换机的入口 buffer 开始积累，当入口 buffer 达到我们设定的阈值时，交换机入口开始主动的迫使它的上级端口降速。</p>
<p><strong>ECN</strong>（Explicit Congestion Notification） 是在交换机<strong>出口（egress port）</strong>发起的拥塞控制机制。当交换机的出口 buffer 达到我们设定的阈值时，交换机会改变数据包头中的 ECN 位来给数据打上 ECN 标签</p>
<img src="/2023/07/08/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/WA8@COU2{LX`RUC27Y`1UV8.png" alt="img" style="zoom:67%;" loading="lazy">

<p>从充分发挥网络高性能转发的角度，我们一般建议==<strong>通过调整ECN和PFC的buffer水线</strong>，<u><strong>让ECN快于PFC触发</strong></u>==，<strong>即网络还是持续全速进行数据转发，让服务器主动降低发包速率。如果还不能解决问题，再通过PFC让上游交换机暂停报文发送，虽然整网吞吐性能降低，但是不会产生丢包。</strong></p>
<h2 id="TIMELY-RTT-based-Congestion-Control-for-the-Datacenter"><a href="#TIMELY-RTT-based-Congestion-Control-for-the-Datacenter" class="headerlink" title="TIMELY: RTT-based Congestion Control for the Datacenter"></a>TIMELY: RTT-based Congestion Control for the Datacenter</h2><p>【==<strong>TIMELY好像没提怎么应对delayed-ACK？</strong>==】</p>
<p>We also measure <strong>the minimum RTT sample in every round</strong>, as prior work has found it to be a robust descriptor <strong>untainted by delayed ACKs</strong> and send/receive offload schemes.</p>
<h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><ul>
<li><p>simple packet delay, measured as round-trip times at hosts, is an effective congestion signal without the need for switch feedback.</p>
<p>逐包延迟是有效的拥塞信号，同时也不需要交换机的反馈</p>
</li>
<li><p>these RTTs are sufficient to estimate switch queueing</p>
<p>RTT足以用来估计交换机的队列</p>
</li>
<li><p>TIMELY is the first delay-based congestion control protocol for use in the datacenter, and it achieves its results despite having an order of magnitude fewer RTT signals (due to NIC<br>offload) than earlier delay-based schemes such as Vegas.</p>
<p>TIMELY是DC中的首个delay-based的CC协议，它用比早期的delay-based的CC（如Vegas）少一个数量级的RTT信号（受限于NIC offload）实现了其结果。</p>
</li>
</ul>
<h3 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h3><ul>
<li><p>使用ECN控制queue occupancy的方法的不足：</p>
<ul>
<li><p>一些场景中，ECN所表示的queue occupancy队列占用并不能直观反映排队延迟</p>
<p>如一个队列中的数据包有多种优先级，尽管队列长度没有超过threshold，低优先级的流量同样有可能经历巨大的delay。这个时候delay反映了occupancy没能反映的拥塞状况。</p>
<blockquote>
<p><em>Multiple queues with different priorities share the same output link, but the ECN mark only provides information about those with occupancy exceeding a threshold. Low priority traffic can experience large queueing delays without necessarily building up a large queue. In such circumstances, <strong>queueing delay reflects the state of congestion in the network which is not reflected by queue occupancy of low priority traffic</strong>.</em></p>
</blockquote>
</li>
<li><p>ECN只能描述单个交换机中的拥塞</p>
<p>而RTT信息累积了端到端的拥塞信息，甚至包括了NIC中的拥塞。</p>
<blockquote>
<p><em>In a highly utilized network, <strong>congestion occurs at multiple switches</strong>, and ECN signals cannot differentiate among them.</em></p>
<p><em>The RTT accumulates information about the end-to-end path. It includes the NIC, which may also become congested but is ignored by most schemes.</em></p>
</blockquote>
</li>
<li><p>RTTs甚至在FCoE中也可以适用</p>
<blockquote>
<p>RTTs work even for the lossless network fabrics commonly used to support FCoE.</p>
<p>FCoE 协议要求底层的物理传输是无损失的；FCoE 不使用 TCP/IP 协议，因此 FCoE 数据传输不能使用 IP 网络，也就无法使用DCTCP这样的CC。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>NIC的发展支持</p>
<blockquote>
<p><em>recent NIC advances do allow data-center RTTs to be measured with sufficient precision.</em></p>
<p><em>recent NICs can accurately record the time of packet transmission and reception without being affected by software-incurred delays.</em></p>
<p><em>These methods must be used with care lest they overly tax the NIC.</em></p>
</blockquote>
</li>
<li><p>RTT作为拥塞信号比ECN更有效。</p>
<p><em>RTT is a rapid, multi-bit signal.</em></p>
<blockquote>
<p><em>As a binary quantity, ECN marks convey a single bit of information, while RTT measurements convey multiple bits and capture the full extent of end to end queueing delay aggregated across multiple switches rather than the presence of queueing exceeding a simple fixed threshold at any one ofN switches.</em></p>
<ul>
<li><em>Figure 2 shows the CDF of RTTs as measured at the end system compared to the queue occupancy measured directly at the switch and shown in units of time computed for a 10 Gbps link. The two CDFs match extremely well.</em></li>
<li><em>Both the scatter and box plots in Figure 3 show only a weak correlation between the fraction of ECN marks and RTTs.</em></li>
</ul>
</blockquote>
</li>
<li><p>RTTs的不足</p>
<p><em>Limitations of RTTs.</em></p>
<blockquote>
<ul>
<li>*RTT measurements lump queueing in both directions along the network path. This may confuse reverse path congestion experienced by ACKs with forward path congestion experienced by data packets.*——send ACKs with higher priority</li>
<li><em>changing network paths have disparate delays</em>——all paths have small propagation delays in datacenters</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="TIMELY-FRAMEWORK"><a href="#TIMELY-FRAMEWORK" class="headerlink" title="TIMELY FRAMEWORK"></a>TIMELY FRAMEWORK</h3><p>三部分：</p>
<ol>
<li><strong>RTT measurement</strong> to monitor the network for congestion; </li>
<li>a <strong>computation engine</strong> that converts RTT signals into target sending rates; and</li>
<li>a <strong>control engine</strong> that inserts delays between segments to achieve the target rate.</li>
</ol>
<p>如下图：</p>
<img src="/2023/07/08/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/image-20230725165753511.png" alt="image-20230725165753511" style="zoom:50%;" loading="lazy">

<h4 id="RTT-Measurement-Engine"><a href="#RTT-Measurement-Engine" class="headerlink" title="RTT Measurement Engine"></a>RTT Measurement Engine</h4><p>==<em>A completion event is generated upon receiving an ACK for <strong>a segment of data</strong> and includes the ACK receive time. The time from when the first packet is sent ($$t_{send}$$) until the ACK is received ($$t_{completion}$$) is defined as the completion time. Unlike TCP, there is one RTT for the set of packets rather than one RTT per 1-2 packets.</em>==</p>
<p><u><em>the timeline of a message: a segment consisting of <strong>multiple packets</strong> is sent as <strong>a single burst</strong> and then <strong>ACKed as a unit</strong> by the receiver.</em></u></p>
<blockquote>
<p>There are several delay components: </p>
<ol>
<li>（传输延迟）the serialization delay to transmit all packets in the segment, typically up to 64 KB;</li>
</ol>
<p>​    <u>(<strong>deterministic function</strong>（确定性函数） of the segment size and the line rate of the NIC)</u><br><strong>2)</strong> （传播延迟）the round-trip wire delay for the segment and its ACK to propagate across the datacenter; </p>
<p>​    <u><strong>the minimum RTT</strong> and fixed for a given flow</u><br>3) the turnaround time at the receiver to generate the ACK; and </p>
<p>​    <u>sufficiently <strong>close to zero</strong> in our setting with NIC-based ACKs that we can ignore it</u><br><strong>4)</strong> （排队延迟）the queuing delay at switches experienced in both directions.</p>
<p>​    <u>causes variation in the RTT, our <strong>focus</strong> for detecting congestion</u></p>
<p>We define the RTT to be the propagation and queueing delay components only.</p>
</blockquote>
<blockquote>
<p>示意图如下图：</p>
<img src="/2023/07/08/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/image-20230725180254555.png" alt="image-20230725180254555" style="zoom:67%;" loading="lazy">

<p>TIMELY running on Host A computes RTT as:<br>$$<br>RTT = t_{completion} - t_{send} - \frac{seg.size}{NIC\ line\ rate}<br>$$<br>The time from when the first packet is sent (tsend) until the ACK is received (tcompletion) is defined as the completion time.</p>
</blockquote>
<h4 id="Rate-Computation-Engine"><a href="#Rate-Computation-Engine" class="headerlink" title="Rate Computation Engine"></a>Rate Computation Engine</h4><p><em>The rate computation engine runs the congestion control algorithm upon each completion event, and outputs an updated target rate for the flow.</em></p>
<h4 id="Rate-Control-Engine"><a href="#Rate-Control-Engine" class="headerlink" title="Rate Control Engine"></a>Rate Control Engine</h4><h3 id="TIMELY-CONGESTION-CONTROL"><a href="#TIMELY-CONGESTION-CONTROL" class="headerlink" title="TIMELY CONGESTION CONTROL"></a>TIMELY CONGESTION CONTROL</h3><h4 id="Metrics-and-Setting"><a href="#Metrics-and-Setting" class="headerlink" title="Metrics and Setting"></a>Metrics and Setting</h4><ul>
<li><p><em><strong>tail (99th percentile) RTT and aggregate throughput</strong></em>: they determine how quickly we complete short and long RPCs (assuming some fairness)</p>
</li>
<li><p>When there is a conflict between throughput and packet RTT, we <em><strong>prefer to keep RTT low</strong></em> at the cost of sacrificing a small amount of bandwidth.</p>
</li>
<li><p><em><strong>fairness and loss</strong></em>: We report both as a <em><strong>check</strong></em> rather than study them in detail.</p>
</li>
<li><p>Finally, we prefer a <em><strong>stable design</strong></em> over <em><strong>higher average, but oscillating rates</strong></em> for the sake of predictable performance.</p>
<p>最后，为了性能可以预测，我们更喜欢一个稳定的设计，而不是平均水平更高的同时振荡率更好。</p>
</li>
</ul>
<h4 id="Delay-Gradient-Approach"><a href="#Delay-Gradient-Approach" class="headerlink" title="Delay Gradient Approach"></a>Delay Gradient Approach</h4><ul>
<li><p>先前的Delay-based CC，如TCP Vegas及受其启发的FAST TCP, Compound TCP的共同特点：</p>
<blockquote>
<p><em>These interpret RTT increase above a baseline as indicative of congestion: they reduce the sending rate <strong>/</strong> if delay is further increased <strong>/</strong> to try and maintain <strong>/</strong> buffer occupancy at the bottleneck queue around some <strong>predefined threshold</strong>.</em></p>
<p>此前的Delay-based CC都是预先设定队列长度（以delay为单位）的阈值，来控制队列长度。</p>
</blockquote>
</li>
<li><p>先前方法的缺陷：</p>
<blockquote>
<ul>
<li><em>it is not possible to control the queue size when it is shorter in time than the control loop delay</em></li>
<li><em>The most any algorithm can do in these circumstances is to control the distribution of the queue occupancy. Even if controlling the queue size were possible, <u>choosing a threshold for a datacenter network in which multiple queues can be a bottleneck is a notoriously hard tuning problem</u>.</em></li>
</ul>
</blockquote>
</li>
<li><p>TIMELY的方法：</p>
<blockquote>
<p><em>TIMELY’s congestion controller achieves low latencies by <strong>reacting to the delay gradient or derivative of the queuing with respect to time</strong>, <strong>instead of trying to maintain a standing queue</strong>.</em></p>
<p><em>By using the <strong>gradient</strong>, we can react to queue growth <strong>without waiting for a standing queue to form</strong> – a strategy that helps us achieve low latencies.</em></p>
</blockquote>
</li>
<li><p>the delay gradient measured through RTT signals acts as an indicator for the rate mismatch at the bottleneck</p>
<p>TIMELY strives to match the <em><strong>aggregate incoming rate y(t)</strong></em> to the <em><strong>drain rate, C</strong></em>, and so adapts its per-connection rate, R(t), in proportion to the measured error of<br>$$<br>\frac{y(t)-C}{C} = \frac{dq(t)}{dt} = \frac{d(RTT)}{dt}<br>$$</p>
<p>  queuing delay through the bottleneck queue: $$q(t)$$</p>
</li>
</ul>
<h4 id="The-Main-Algorithm"><a href="#The-Main-Algorithm" class="headerlink" title="The Main Algorithm"></a>The Main Algorithm</h4><p>根据新RTT的值，来adjust sending rate</p>
<img src="/2023/07/08/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/image-20230802222336780.png" alt="image-20230802222336780" style="zoom:67%;" loading="lazy">

<blockquote>
<p><em><strong>Connections sending at a higher rate observe a stronger decrease in their rate, while the increase in rate remains same for all connections.</strong></em></p>
</blockquote>
<blockquote>
<p><strong>Need for RTT low threshold $$T_{low}$$</strong></p>
<p><em>large segments (that can be as large as 64 KB) lead to <strong>packet bursts</strong>, which result in transient queues in the network and hence RTT spikes when there is an occasional collision</em></p>
<p>$$T_{low}$$ <em>is a (nonlinear) <strong>increasing function of the segment size</strong> used in the network, since larger messages cause more bursty queue occupancy.</em></p>
</blockquote>
<blockquote>
<p><strong>Need for RTT low threshold $$T_{high}$$</strong></p>
<p><em>in theory, it is possible for the gradient to stay at zero while the queue remains at a high, fixed level</em></p>
<p><em>To remove this concern, Thigh serves as an upper bound on the tolerable end-to-end network queue delay, i.e., the tail latency.</em></p>
<p><em>Note that we use the <strong>instantaneous</strong> rather than smoothed RTT.</em></p>
<p><em>Our finding is inline with [27] which shows through a control theoretic analysis that the <strong>averaged queue length is a failing of RED AQM</strong></em></p>
</blockquote>
<blockquote>
<p><strong>Hyperactive increase (HAI) for faster convergence.</strong></p>
</blockquote>
<h4 id="Gradient-versus-Queue-Size"><a href="#Gradient-versus-Queue-Size" class="headerlink" title="Gradient versus Queue Size"></a>Gradient versus Queue Size</h4><p><em><strong>Gradient</strong></em> versus <em><strong>Queue Size</strong></em></p>
<blockquote>
<p>If we set the same value for $$T_{low}$$and $$T_{high}$$, then TIMELY congestion control <em><strong>reduces to a queue size based approach</strong></em> (similar to TCP FAST algorithm; FAST in turn is a scaled, improved version of Vegas).</p>
</blockquote>
<blockquote>
<p>We see that the queue size approach can maintain either low latency or high throughput, but <em><strong>finds it hard to do both</strong></em>.</p>
</blockquote>
<blockquote>
<p>the connection rates <em><strong>oscillate</strong></em> more in the queue-size approach, as it drives the RTT up and down towards the target queue size.</p>
</blockquote>
<blockquote>
<p>The main take-away is that $$T_{low}$$and $$T_{high}$$ thresholds effectively bring the delay within a target range and <em><strong>play a role similar to the target queue occupancy</strong></em> in many AQM schemes.</p>
</blockquote>
<h3 id="IMPLEMENTATION"><a href="#IMPLEMENTATION" class="headerlink" title="IMPLEMENTATION"></a>IMPLEMENTATION</h3><ul>
<li><p><strong>Transport Interface</strong></p>
<p><em>TIMELY is concerned with the <strong>congestion control</strong> portion of the transport protocol; it is not concerned with reliability or the higher-level interface the transport exposes to applications. This allows <strong>the interface to the rest of the transport to be simple: message send and receive</strong>.</em></p>
</li>
<li><p><strong>Using NIC Completions for RTT Measurement</strong></p>
<blockquote>
<p>NIC records: <em>absolute timestamp of when the multi-packet operation <strong>finishes</strong></em></p>
<p>userspace software records: <em>the operation <strong>was posted to</strong> the NIC</em></p>
<p>(reason: We consider any NIC queuing occurring to be part of the RTT signal.)</p>
<p>我们需要将网卡的排队时间也考虑在内，NIC记录的时间戳不包含这个时间，software记录的时间戳包含；但是由于NIC比较准确，想使用NIC的时间，所以需要将software映射到NIC timestamps，这里使用线性映射</p>
<img src="/2023/07/08/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/image-20230811171105109.png" alt="image-20230811171105109" style="zoom:67%;" loading="lazy">
</blockquote>
<p><em>This requires a scheme to map <strong>host</strong> clock to <strong>NIC</strong> clock, as well as calibration. A simple <strong>linear mapping</strong> is sufficient.</em></p>
</li>
<li><p><strong>RDMA rate control.</strong></p>
<p>RDMA Writes: TIMELY on the sender <strong>directly controls</strong> the segment pacing rate.</p>
<p>RDMA Reads: the receiver <strong>issues read requests</strong>, in response to which the remote host performs a DMA of the data segments. (<strong>pacing the read requests</strong>)</p>
</li>
<li><p><strong>Application limited behavior.</strong></p>
<p>Applications do not always have enough data to transmit for their flows to reach the target rate. </p>
<p>When this happens, we do not want to inadvertently increase the target rate without bound because the network appears to be uncongested. 在app向下发数据的速率小于target rate的时候，网络看起来是没有拥塞的，但此时并不能表明网络无拥塞，所以不能盲目提高发送速率。</p>
<p>To prevent this problem, we let the target rate increase only if the application is sending at more than 80% of the target rate, and we also cap the maximum target rate at 10 Gbps.</p>
</li>
<li><p><strong>Rate update frequency.</strong></p>
</li>
</ul>
<h2 id="Swift-Delay-is-Simple-and-Effective-for-Congestion-Control-in-the-Datacenter"><a href="#Swift-Delay-is-Simple-and-Effective-for-Congestion-Control-in-the-Datacenter" class="headerlink" title="Swift: Delay is Simple and Effective for Congestion Control in the Datacenter"></a>Swift: Delay is Simple and Effective for Congestion Control in the Datacenter</h2><p>Swift targets an <strong>end-to-end</strong> delay by using <strong>AIMD</strong> control, with <strong>pacing</strong> under extreme congestion.</p>
<p>Delay is easy to decompose into <em><strong>fabric</strong></em> and <em><strong>host</strong></em> components to separate concerns.</p>
<p>细化了delay的组成，强调了endpoints上产生的delay</p>
</div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>wan_nan</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="https://wan-nan.github.io/2023/07/08/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/" title="文献阅读">https://wan-nan.github.io/2023/07/08/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本博客所有文章除特别声明外，均默认采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><svg class="icon"><use xlink:href="#icon-creative-commons-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-by-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-nc-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-sa-line"></use></svg></a> 许可协议。</li></ul></section></article><div class="post-nav"><div class="post-nav-item"></div><div class="post-nav-item"><a class="post-nav-next" href="/2023/06/30/GDB-skills/" rel="next" title="GDB skills"><span class="post-nav-text">GDB skills</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-right-s-line"></use></svg></a></div></div></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2021 – 2023 </span><span class="with-love" id="animate"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-cloud-line"></use></svg></span><span class="author"> wan_nan</span></div><div class="live_time"><span>本博客已悄悄运行</span><span id="display_live_time"></span><span class="moe-text">(●'◡'●)</span><script>function blog_live_time() {
  setTimeout(blog_live_time, 1000);
  const start = new Date('2021-07-03T00:00:00');
  const now = new Date();
  const timeDiff = (now.getTime() - start.getTime());
  const msPerMinute = 60 * 1000;
  const msPerHour = 60 * msPerMinute;
  const msPerDay = 24 * msPerHour;
  const passDay = Math.floor(timeDiff / msPerDay);
  const passHour = Math.floor((timeDiff % msPerDay) / 60 / 60 / 1000);
  const passMinute = Math.floor((timeDiff % msPerHour) / 60 / 1000);
  const passSecond = Math.floor((timeDiff % msPerMinute) / 1000);
  display_live_time.innerHTML = " " + passDay + " 天 " + passHour + " 小时 " + passMinute + " 分 " + passSecond + " 秒";
}
blog_live_time();
</script></div><div id="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv" title="总访客量"><span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-user-line"></use></svg></span><span id="busuanzi_value_site_uv"></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv" title="总访问量"><span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-eye-line"></use></svg></span><span id="busuanzi_value_site_pv"></span></span></div></footer><a class="hty-icon-button" id="back-to-top" aria-label="back-to-top" href="#"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-up-s-line"></use></svg><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#0078E7" stroke-width="2" stroke-linecap="round"></circle></svg></a><div class="aplayer no-destroy" id="aplayer" data-id="8293178209" data-server="tencent" data-type="playlist" data-fixed="true" data-theme="#0078E7" data-loop="all" data-order="list" data-preload="auto" data-volume="0.7" data-mutex data-lrctype="0" data-listmaxheight="340px" data-storagename="metingjs"></div></div></body></html>