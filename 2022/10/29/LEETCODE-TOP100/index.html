<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#0078E7"><meta name="author" content="wan_nan"><meta name="copyright" content="wan_nan"><meta name="generator" content="Hexo 5.4.0"><meta name="theme" content="hexo-theme-yun"><title>LEETCODE | 风物</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/star-markdown-css@0.1.25/dist/yun/yun-markdown.min.css"><script src="//at.alicdn.com/t/font_1140697_dxory92pb0h.js" async></script><script src="https://cdn.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>document.addEventListener("DOMContentLoaded", () => {
  [".post-card",".post-content img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
});
</script><link class="aplayer-style-marker" rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script class="aplayer-script-marker" src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" defer></script><script class="meting-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/pjax@latest/pjax.min.js" defer></script><script src="/js/pjax.js" defer></script><script src="https://cdn.jsdelivr.net/npm/vue@2.6.11"></script><link rel="icon" href="/dino.png"><link rel="mask-icon" href="/dino.png" color="#0078E7"><link rel="alternate icon" href="/yun.ico"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="preload" href="/js/utils.js" as="script"><link rel="preload" href="/js/hexo-theme-yun.js" as="script"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><script id="yun-config">
    const Yun = window.Yun || {};
    window.CONFIG = {"hostname":"wan-nan.github.io","root":"/","title":"风物的小站","version":"1.6.1","mode":"auto","copycode":true,"page":{"isPost":true},"i18n":{"placeholder":"搜索...","empty":"找不到您查询的内容: ${query}","hits":"找到 ${hits} 条结果","hits_time":"找到 ${hits} 条结果（用时 ${time} 毫秒）"},"anonymous_image":"https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/avatar/none.jpg","say":{"api":"https://el-bot-api.vercel.app/api/words/young"},"fireworks":{"colors":["102, 167, 221","62, 131, 225","33, 78, 194"]}};
  </script><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script src="/js/utils.js"></script><script src="/js/hexo-theme-yun.js"></script><link rel="preconnect" href="https://www.google-analytics.com" crossorigin><script async src="https://www.googletagmanager.com/gtag/js?id=G-1LL0D86CY9"></script><script>if (CONFIG.hostname === location.hostname) {
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-1LL0D86CY9');
}</script><script>//- only for pjax
function sendPageView() {
  if (CONFIG.hostname !== location.hostname) return;
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('event', 'page_view', {
    page_path: encodeURIComponent(location.pathname),
  })
}
document.addEventListener("pjax:success", sendPageView);</script><script data-ad-client="ca-pub-2245427233262012" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(function(){
  var bp = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  if (curProtocol === 'https') {
    bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else {
    bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(bp, s);
})();</script><!-- Google Tag Manager --><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src='https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','GTM-M9KWR9L');</script><!-- End Google Tag Manager --><meta name="description" content="打勾的是当时自己动手做出来的 加粗的是当时有问题的  来源：🔥 LeetCode 热题 HOT 100 &amp; 每日一题 &amp; 以前做过的题目 &amp; 周赛题目 周赛题目总结：【灵茶山艾府】2022 年周赛题目总结（上篇）  从周赛中学算法 - 2022 年周赛题目总结（下篇）  做题的时候尽量带着纸笔在纸上比比划划   注意点：  结果对1e9+7取模： 注意可能出现的负数，要">
<meta property="og:type" content="article">
<meta property="og:title" content="LEETCODE">
<meta property="og:url" content="https://wan-nan.github.io/2022/10/29/LEETCODE-TOP100/index.html">
<meta property="og:site_name" content="风物">
<meta property="og:description" content="打勾的是当时自己动手做出来的 加粗的是当时有问题的  来源：🔥 LeetCode 热题 HOT 100 &amp; 每日一题 &amp; 以前做过的题目 &amp; 周赛题目 周赛题目总结：【灵茶山艾府】2022 年周赛题目总结（上篇）  从周赛中学算法 - 2022 年周赛题目总结（下篇）  做题的时候尽量带着纸笔在纸上比比划划   注意点：  结果对1e9+7取模： 注意可能出现的负数，要">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://wan-nan.github.io/2022/10/29/LEETCODE-TOP100/image-20221102170200429.png">
<meta property="og:image" content="https://wan-nan.github.io/2022/10/29/LEETCODE-TOP100/image-20230106172140290.png">
<meta property="article:published_time" content="2022-10-29T02:51:46.000Z">
<meta property="article:modified_time" content="2023-06-28T18:18:04.004Z">
<meta property="article:author" content="wan_nan">
<meta property="article:tag" content="刷题">
<meta property="article:tag" content="daily">
<meta property="article:tag" content="学习">
<meta property="article:tag" content="Leetcode">
<meta property="article:tag" content="工作面试">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://wan-nan.github.io/2022/10/29/LEETCODE-TOP100/image-20221102170200429.png"><script src="/js/ui/mode.js"></script></head><body><script defer src="https://cdn.jsdelivr.net/npm/animejs@latest"></script><script defer src="/js/ui/fireworks.js"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/js/sidebar.js"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button" data-target="post-toc-wrap" title="文章目录"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-list-ordered"></use></svg></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button sidebar-nav-active" data-target="site-overview-wrap" title="站点概览"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-passport-line"></use></svg></li></ul><div class="sidebar-panel sidebar-panel-active" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about/" title="wan_nan"><img width="96" loading="lazy" src="/images/avatar.jpg" alt="wan_nan"><span class="site-author-status" title="sleeping">😴</span></a><div class="site-author-name"><a href="/about/">wan_nan</a></div><span class="site-name">风物</span><sub class="site-subtitle">Yeah!</sub><div class="site-desciption">个人博客</div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="首页"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-home-4-line"></use></svg></span></a><div class="site-state-item"><a href="/archives/" title="归档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-archive-line"></use></svg></span><span class="site-state-item-count">53</span></a></div><div class="site-state-item"><a href="/categories/" title="分类"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-2-line"></use></svg></span><span class="site-state-item-count">3</span></a></div><div class="site-state-item"><a href="/tags/" title="标签"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="site-state-item-count">40</span></a></div><a class="site-state-item hty-icon-button" href="/about/#comment" title="留言板"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-clipboard-line"></use></svg></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="http://wpa.qq.com/msgrd?v=3&amp;uin=2213324970&amp;site=qq&amp;menu=yes" title="QQ" target="_blank" style="color:#12B7F5"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-qq-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/wan-nan" title="GitHub" target="_blank" style="color:#181717"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-github-line"></use></svg></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-contrast-2-line"></use></svg></a></div><div class="sidebar-panel" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content">此文章未包含目录</div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="hty-card post-block" itemscope itemtype="https://schema.org/Article"><link itemprop="mainEntityOfPage" href="https://wan-nan.github.io/2022/10/29/LEETCODE-TOP100/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="wan_nan"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="风物"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">LEETCODE</h1><div class="post-meta"><div class="post-time" style="display:block"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-line"></use></svg></span> <time title="创建时间：2022-10-29 10:51:46" itemprop="dateCreated datePublished" datetime="2022-10-29T10:51:46+08:00">2022-10-29</time><span class="post-meta-divider">-</span><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-2-line"></use></svg></span> <time title="修改时间：2023-06-29 02:18:04" itemprop="dateModified" datetime="2023-06-29T02:18:04+08:00">2023-06-29</time></div><span class="post-count"><span class="post-symbolcount"><span class="post-meta-item-icon" title="本文字数"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-file-word-line"></use></svg></span> <span title="本文字数">6.4k</span><span class="post-meta-divider">-</span><span class="post-meta-item-icon" title="阅读时长"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-timer-line"></use></svg></span> <span title="阅读时长">24m</span></span></span><span class="post-busuanzi"><span class="post-meta-divider">-</span><span class="post-meta-item-icon" title="阅读次数"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-eye-line"></use></svg> <span id="busuanzi_value_page_pv"></span></span></span><div class="post-classify"><span class="post-category"> <span class="post-meta-item-icon" style="margin-right:3px;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-line"></use></svg></span><span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a class="category-item" href="/categories/%E7%AC%94%E8%AE%B0/" style="--text-color:dimgray" itemprop="url" rel="index"><span itemprop="text">笔记</span></a></span></span><span class="post-tag"><span class="post-meta-divider">-</span><a class="tag-item" href="/tags/%E5%88%B7%E9%A2%98/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">刷题</span></a><a class="tag-item" href="/tags/daily/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">daily</span></a><a class="tag-item" href="/tags/%E5%AD%A6%E4%B9%A0/" style="--text-color:saddlebrown"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">学习</span></a><a class="tag-item" href="/tags/Leetcode/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">Leetcode</span></a><a class="tag-item" href="/tags/%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">工作面试</span></a></span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body" style="--smc-primary:#0078E7;"><blockquote>
<p>打勾的是当时自己动手做出来的</p>
<p>加粗的是当时有问题的</p>
</blockquote>
<p>来源：<a target="_blank" rel="noopener" href="https://leetcode.cn/problem-list/2cktkvj/">🔥 LeetCode 热题 HOT 100</a> &amp; 每日一题 &amp; 以前做过的题目 &amp; 周赛题目</p>
<p>周赛题目总结：<a target="_blank" rel="noopener" href="https://leetcode.cn/circle/discuss/G0n5iY/">【灵茶山艾府】2022 年周赛题目总结（上篇）</a>  <a target="_blank" rel="noopener" href="https://leetcode.cn/circle/discuss/WR1MJP/">从周赛中学算法 - 2022 年周赛题目总结（下篇）</a></p>
<blockquote>
<p>做题的时候尽量带着纸笔在纸上比比划划</p>
</blockquote>
<ul>
<li><p>注意点：</p>
<ul>
<li><p>结果对1e9+7取模：</p>
<p>注意可能出现的负数，<strong>要先判断是负数，才能先加再模</strong>，不然可能出现取模之前就会因为加了1e9+7而整数溢出</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(dp[i][j]&lt;<span class="number">0</span>)</span><br><span class="line">    dp[i][j]+=<span class="number">1000000007</span>;</span><br><span class="line">dp[i][j]%=<span class="number">1000000007</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>【整数溢出】long long用long代替（因为现在都是64bits的机器，所以可以这么写）</p>
</li>
</ul>
</li>
<li><p>很容易见到的方法</p>
<ul>
<li><p><strong>二分</strong></p>
<p>最简单的二分要求单调，但是也可以值域二分（最小化最大值）</p>
<p>6346、6355、4、34</p>
<p>很难逐步确定答案，但是可以确定答案的上下界，同时验证答案是否正确的复杂度很低</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> l=<span class="built_in">lower_bound</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>(),lower)-nums.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">int</span> r=<span class="built_in">upper_bound</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>(),upper)-nums.<span class="built_in">begin</span>();</span><br></pre></td></tr></table></figure></li>
<li><p><strong>动态规划</strong></p>
<p>1130（区间dp）、53/1186（最大子数组和）</p>
</li>
<li><p><strong>双指针（滑动窗口）</strong></p>
<p>1234、75、3、1616</p>
</li>
<li><p><strong>预处理</strong></p>
<p>6340、42</p>
<ul>
<li><p>前缀后缀</p>
<p>6357</p>
</li>
<li><p>前缀和+哈希</p>
<p>1124、560、1590、面试题 17.05、2488</p>
</li>
</ul>
</li>
<li><p><strong>单调栈</strong></p>
<p>456</p>
<p>（常常辅之以预处理）</p>
</li>
<li><p><strong>二叉树（回溯、递归）</strong></p>
<p>1145、1373、1080</p>
</li>
<li><p><strong>贪心</strong></p>
<p>1145</p>
</li>
<li><p><strong>STL使用</strong></p>
</li>
<li><p><strong>Trie树</strong></p>
<p>208、648</p>
</li>
<li><p><strong>字符串处理</strong></p>
</li>
<li><p>图论</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/cracking-the-safe/description/">欧拉回路</a></p>
</li>
<li><p><a href="https://wan-nan.github.io/2022/07/23/%E5%89%91%E6%8C%87Offer-II%E2%80%94%E2%80%94115.%E9%87%8D%E5%BB%BA%E5%BA%8F%E5%88%97%EF%BC%88%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%EF%BC%89/">拓扑排序</a>（保存入度和全图）</p>
<p>210</p>
</li>
<li><p><strong>DFS/BFS</strong></p>
<p>n1、1210、1079、1091</p>
<p>好久没遇到，以至于这种简单暴力的方法反而很陌生</p>
<p>BFS比DFS陌生</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>【<a target="_blank" rel="noopener" href="https://www.acwing.com/blog/content/32/">时间复杂度控制</a>】</p>
<blockquote>
<p>一般ACM或者笔试题，或者力扣上的题目的时间限制是1秒或2秒。</p>
<p>在这种情况下，C++代码中的操作次数控制在 <strong>1e7</strong> 为最佳。</p>
<hr>
<ol>
<li><p>$$n≤30$$</p>
<p>指数级别，dfs+剪枝，状态压缩dp</p>
</li>
<li><p>$$n≤100 → O(n^3)$$</p>
<p>floyd，dp，高斯消元</p>
</li>
<li><p>$$n≤10^3 → O(n^2)，O(n^2logn)$$</p>
<p>dp，二分，朴素版Dijkstra、朴素版Prim、Bellman-Ford</p>
<p><strong>分界点（一旦n到达$$10^4$$，就不适合n^2^的暴力解法）</strong></p>
</li>
<li><p>$$n≤10^4 → O(n\sqrt{n})$$</p>
<p>块状链表、分块、莫队</p>
</li>
<li><p>$$n≤10^5 → O(nlogn)$$ </p>
<p>各种sort，线段树、树状数组、set/map、heap、拓扑排序、dijkstra+heap、prim+heap、Kruskal、spfa、求凸包、求半平面交、<strong>二分</strong>、CDQ分治、整体二分、后缀数组、树链剖分、动态树</p>
</li>
<li><p>$$n≤10^6 → O(n), 以及常数较小的 O(nlogn) 算法$$ </p>
<p>单调队列、 hash、双指针扫描、并查集，kmp、AC自动机</p>
<p>常数比较小的 O(nlogn) 的做法：sort、树状数组、heap、dijkstra、spfa</p>
</li>
<li><p>$$n≤10^7 → O(n)$$</p>
<p>双指针扫描、kmp、AC自动机、线性筛素数</p>
</li>
<li><p>$$n≤10^9 → O(√n)$$，</p>
<p>断质数</p>
</li>
<li><p>$$n≤10^{18} → O(logn)$$</p>
<p>最大公约数，快速幂，数位DP</p>
</li>
</ol>
</blockquote>
</li>
</ul>
<hr>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subsets/description/">78.子集</a></p>
<ul>
<li>mask</li>
<li>DFS</li>
</ul>
</li>
<li><p><strong><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/description/">297. 二叉树的序列化与反序列化</a></strong></p>
<ul>
<li>前中后序遍历</li>
<li>层序遍历</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/solutions/1536508/by-peaceful-thompsonfsu-8143/">参考题解</a></p>
<blockquote>
<p>后面重温的过程中发现：【超出内存限制】指的是爆栈</p>
<p>因为将字符串中间结果作为参数在传递，这个过程比较占空间</p>
<p>后续改成只保存一个全局变量即可通过</p>
<p><strong>（所以全局变量相较于堆栈传参也是有好处的）</strong></p>
</blockquote>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/jump-game/">55. 跳跃游戏</a></p>
</li>
<li><p><input disabled type="checkbox">  **<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-k-sorted-lists/description/">23. 合并K个升序链表</a>**【好题】</p>
<p>1e6的数据不能犯蠢用排序</p>
<p><strong>O(n)时间+O(1)空间 合并链表</strong></p>
<ul>
<li>（暴力）多次重复双指针【会暴力的即可】</li>
<li>（分治）联想归并排序的merge环节</li>
<li>（堆排序）联想堆排序</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-k-sorted-lists/solutions/219756/he-bing-kge-pai-xu-lian-biao-by-leetcode-solutio-2/">参考题解</a></p>
<p>共n个子链表，每个子链表最长有k个元素，当k=1时不就是正常的排序吗？</p>
<p>上面的三种解法其实也就对应三种排序算法</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/product-of-array-except-self/description/">238. 除自身以外数组的乘积</a></p>
<p><u>序列乘积与序列之和的区别是可以减，但是除法会遇到0出问题</u></p>
</li>
<li><p><strong><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-product-subarray/description/">152. 乘积最大子数组</a></strong></p>
<p>（动态规划），还与<strong>和最大的子数组</strong>的转移方程不同</p>
<p>用 $f_{\max}(i)$ 来表示<strong>以第 i 个元素结尾</strong>的乘积最大子数组的乘积</p>
<p>用 $f_{\min}(i)$ 来表示<strong>以第 i 个元素结尾</strong>的乘积最小子数组的乘积</p>
</li>
<li><p><strong><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-palindromic-substring/description/">5. 最长回文子串</a></strong></p>
<p>（动态规划）<u>找到可以用于转移方程的性质，本题中是回文串两边各去掉一个字符仍然是回文串</u></p>
<p>按照length从小到大进行规划即可</p>
<p>（中心扩展算法）枚举所有可能的回文串中心，向两边扩张，找到最长的</p>
<blockquote>
<p>这道题只要不是暴力，$O(n^2)$就能过</p>
<p>要先从暴力解法出发，想办法优化，暴力遍历所有可能的子串复杂度$O(n^2)$，判断每个子串是否是回文串复杂度$O(n)$，后者这个过程可以优化，使用dp复用之前的结果</p>
</blockquote>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/counting-bits/">338. 比特位计数</a></p>
<p>入门（动态规划）</p>
</li>
<li><p><strong><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subarray-sum-equals-k/description/">560. 和为 K 的子数组</a></strong></p>
<p>还是那个思路：先写暴力，再优化</p>
<blockquote>
<p>本来想法是双指针，后面看到数据可能是负的，没有单调性，所以<strong>不能用双指针</strong></p>
<p>前缀和+哈希</p>
<p>（和1124很像）</p>
</blockquote>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/symmetric-tree/description/">101. 对称二叉树</a></p>
<p>迭代的方法不好想，进入队列的顺序比较关键</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/number-of-islands/description/">200. 岛屿数量</a></p>
<p>用bfs，更改标记数组的时机居然导致了被卡时间，我不理解</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/convert-bst-to-greater-tree/description/">538. 把二叉搜索树转换为累加树</a></p>
<p>中序遍历的变体</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-all-numbers-disappeared-in-an-array/description/">448. 找到所有数组中消失的数字</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-level-order-traversal/description/">102. 二叉树的层序遍历</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/3sum/description/">15. 三数之和</a></p>
<p>数组中三个数之和为0的<strong>所有组合</strong></p>
<p>还是那个思路：先想到$O(n^3)$的暴力，再用哈希去优化</p>
<p>还有就是如何避免出现重复的三元组：先排序，再避免i/j处的值与前一个i/j相同</p>
<ul>
<li><p>还可以变体为：三个数之和为任意一个给定常数</p>
<p>思路都是<strong>先排序</strong>，然后用<strong>左右双指针</strong>或用<strong>unordered_map存储最右边的位置</strong>，复杂度都是$O(n^2)$</p>
</li>
<li><p>但是这道题：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/3sum-closest/description/">16. 最接近的三数之和</a><strong>只能用双指针</strong></p>
<p>要是上面这题怎么优化，则是用各种判断提前退出循环的方式优化，<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/3sum-closest/solutions/33542/dui-shuang-zhi-zhen-fa-jin-xing-yi-dian-you-hua-da/">参考</a></p>
</li>
</ul>
</li>
<li><p><strong><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/largest-rectangle-in-histogram/">84. 柱状图中最大的矩形</a></strong></p>
<p>单调栈的应用：<u>一遍遍历求所有元素两边第一个比其小的元素的位置</u></p>
<blockquote>
<p>一个元素进入单调递增栈后，左侧相邻的元素是<strong>左侧第一个比它小的元素</strong>；</p>
<p>元素被<code>pop()</code>出栈时，为了进栈将其挤出去的元素是<strong>右侧第一个比它小的元素</strong>；</p>
</blockquote>
<hr>
<blockquote>
<p>本来只能写个$O(n^2)$的暴力，但是看了题目的tag有单调栈，就往这里想，最后写出来的，没看题解但看了tag</p>
<p>一道hard交了六次，后面头都是晕的了</p>
<img src="/2022/10/29/LEETCODE-TOP100/image-20221102170200429.png" alt="image-20221102170200429" style="zoom:67%;" loading="lazy"> </blockquote>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-linked-list/description/">206.反转链表</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/">19. 删除链表的倒数第 N 个结点</a></p>
<p>快慢指针（双指针）</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/description/">17. 电话号码的字母组合</a></p>
<p>简简单单dfs</p>
</li>
<li><p><input disabled type="checkbox">  2022/11/5暂时暂停吧</p>
<p>啥都不会，找个🔨实习</p>
<p>2022/12/20接着刷</p>
</li>
<li><p><strong><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-limit-of-balls-in-a-bag/description/">1760. 袋子里最少数目的球</a></strong></p>
<p><strong>二分</strong>变体（太久没做题，看了tag才想出来）</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-number-of-homogenous-substrings/description/">1759. 统计同构子字符串的数目</a></p>
<blockquote>
<ol>
<li><p><strong>有求和就小心溢出，用long long int表示</strong></p>
</li>
<li><blockquote>
<p><strong>只需返回对 <code>1e9 + 7</code> 取余 后的结果</strong></p>
</blockquote>
<p><strong>注意看题目的限制</strong></p>
<p><strong>另外，如果可能会出现负数，最好用ans先加上1e9 + 7再取模</strong></p>
</li>
</ol>
</blockquote>
</li>
<li><p><strong><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/container-with-most-water/description/?favorite=2cktkvj">11. 盛最多水的容器</a></strong></p>
<p><strong>双指针</strong>！！！！！</p>
<p>不是单调栈，不要误会</p>
<p>==和<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/largest-rectangle-in-histogram/">84. 柱状图中最大的矩形</a>对比，非常相似，但是一个是双指针，一个是单调栈==</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/serialize-and-deserialize-bst/description/">449. 序列化和反序列化二叉搜索树</a></p>
<p>递归，之前做过这题</p>
</li>
<li><p><strong><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/climbing-stairs/description/">70. 爬楼梯</a></strong></p>
<p><strong>动态规划</strong></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/description/">124. 二叉树中的最大路径和</a></p>
<p>遇到二叉树相关，八成要用<strong>递归</strong>，把每个子树都当成新的新的树看待</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/c5db069fd9d64e6e9cf5fd68860abcdd">nowcoder.36进制加法</a></p>
<p><code>string.append(int cnt,  char c)</code>，在string的末尾添加<code>cnt</code>个字符<code>c</code></p>
</li>
<li><p><strong><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/exam-room/description/">855. 考场就座</a></strong></p>
<ul>
<li><p>STL的使用</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/vir_lee/article/details/81544618">set</a></p>
<p><code>set.find()</code>的返回值是iterator，前一个元素是<code>prev(iterator)</code>，后一个元素是<code>next(iterator)</code></p>
<p>集合的开始元素的iterator是<code>set.begin()</code>，结束元素是<code>set.end()</code>（正向迭代器）或<code>set.rbegin()</code>（反向迭代器）</p>
<p>删除set中的元素：<code>set.erase(value)</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (p != *seats.<span class="built_in">begin</span>() &amp;&amp; p != *seats.<span class="built_in">rbegin</span>()) &#123;</span><br><span class="line">    <span class="keyword">auto</span> it = seats.<span class="built_in">find</span>(p);</span><br><span class="line">    pq.<span class="built_in">push</span>(&#123;*<span class="built_in">prev</span>(it), *<span class="built_in">next</span>(it)&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>priority_queue：</p>
<p>自定义类型的优先队列，重载<code>&lt;</code>运算符，注意所有的关系运算符都是左结合的，所以<code>bool operator&lt;(const section&amp; b) const&#123;&#125;</code>的函数体要表达的应该是<code>*this &lt; b</code></p>
<p>另外，按照上面的语义正确重载小于运算符，<code>priority_queue</code>是<strong>大顶堆</strong>，即优先级高的在堆顶；<code>sort</code>是<strong>从小到大</strong>排序</p>
</li>
</ul>
</li>
<li><p>延迟删除的思想</p>
<p><code>priority_queue</code>中只能出队<code>top()</code>，没办法立即删除中间位置的成员，所以可以做好标记，等用到的时候检查标记，有删除标记则进行删除</p>
</li>
</ul>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/number-of-orders-in-the-backlog/description/">1801. 积压订单中的订单总数</a></p>
<ul>
<li><p>自定义类型的<code>priority_queue</code>以及<code>&lt;</code>符号的重载</p>
</li>
<li><blockquote>
<p>只需返回对 <code>1e9 + 7</code> <strong>取余</strong> 后的结果</p>
</blockquote>
<p>注意看题目的限制</p>
<p>另外，<strong>如果可能会出现负数，最好用ans先加上1e9 + 7再取模</strong></p>
</li>
</ul>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-value-at-a-given-index-in-a-bounded-array/description/">1802. 有界数组中指定下标处的最大值</a></p>
<ul>
<li>二分：【已知解的左右边界，求最优解】，$$check()的复杂度×logn$$</li>
<li><strong>有【大的数求和or单增数列求和】就小心溢出，用long long int表示</strong></li>
</ul>
</li>
<li><p><strong><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-increasing-subsequence/description/">300. 最长递增子序列</a></strong></p>
<p>两种做法</p>
<ul>
<li>$$O(n^2)$$ 动态规划</li>
<li><strong>$$O(nlogn)$$  dp+贪心+二分</strong></li>
</ul>
</li>
<li><p><strong><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/prefix-and-suffix-search/description/">745. 前缀和后缀搜索</a></strong></p>
<p>22年暑假做的题目，当时的记录：<a href="https://wan-nan.github.io/2022/07/14/745.%E5%89%8D%E7%BC%80%E5%92%8C%E5%90%8E%E7%BC%80%E6%90%9C%E7%B4%A2%EF%BC%88Trie%E5%86%99%E6%B3%95%EF%BC%89/">745.前缀和后缀搜索（Trie写法）</a></p>
<p>三种方法：单字典树/哈希/双字典树</p>
<p>字典树的便捷写法可以记一下：</p>
<img src="/2022/10/29/LEETCODE-TOP100/image-20230106172140290.png" alt="image-20230106172140290" style="zoom: 67%;" loading="lazy"></li>
<li><p><strong><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-xor-of-two-numbers-in-an-array/description/">421. 数组中两个数的最大异或值</a></strong></p>
<p>经典的<strong>区间元素异或</strong>的问题，还是用<strong>字典树</strong>解决</p>
<p>（还没上手做）</p>
</li>
<li><p><strong><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-pairs-with-xor-in-a-range/description/">1803. 统计异或值在范围内的数对有多少</a></strong></p>
<p>（不仅没上手做，连怎么做还没看懂）</p>
</li>
<li><p><strong><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-operations-to-reduce-x-to-zero/description/">1658. 将 x 减到 0 的最小操作数</a></strong></p>
<p>正统做法应该是<strong>双指针（也可以叫做滑动窗口）</strong></p>
<p>我用的哈希做的，题目不难，但是可能方法比较陌生</p>
</li>
<li><p><input disabled type="checkbox">  总是容易漏掉很多情况</p>
<p>下面这种写法不对，<strong>因为else if是和if(cond2)对齐的</strong>！！！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(cond1)</span><br><span class="line">    <span class="keyword">if</span>(cond2)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(cond3)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/counting-words-with-a-given-prefix/description/">2185. 统计包含给定前缀的字符串</a></p>
<p><code>string.find(pref,0) == 0</code></p>
<p><code>string.find()</code>（<a target="_blank" rel="noopener" href="https://www.cnblogs.com/wkfvawl/p/9429128.html">参考</a>）返回的是int（position），不是iterator</p>
</li>
<li><p><strong><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/make-number-of-distinct-characters-equal/description/">6284. 使字符串总不同字符的数目相等</a></strong></p>
<p>327th场周赛第三题，我直接怒写接近100行代码，实际上20行就能搞定，总是容易把题目想复杂</p>
<p>可以再做一下，简单的模拟，但是容易写的很复杂</p>
</li>
<li><p><strong><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/cracking-the-safe/description/">753. 破解保险箱</a></strong></p>
<p><u>欧拉回路</u></p>
<p>可以把题目转化成在每个节点的入度和出度都为k的有向图中，找到一条欧拉回路，可以<strong>用DFS找欧拉回路</strong></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/cracking-the-safe/solutions/275196/yi-bu-yi-bu-tui-dao-chu-0ms-jie-fa-tan-xin-gou-zao/">参考</a></p>
<p>（注意回路和通路不一样）</p>
</li>
<li><p><strong><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reconstruct-itinerary/description/">332. 重新安排行程</a></strong></p>
<p>和上面的题类似，但这个找的是<u><strong>欧拉通路</strong></u>，不过也是用<strong>DFS</strong>的方法找</p>
<ul>
<li>欧拉是每条边都只能走一次（如这个使用机票的行程问题）</li>
<li>哈密顿是每个点都只能走一次（暂时还没遇到这类问题）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt; &gt; pq;</span><br></pre></td></tr></table></figure>

<p>对<code>priority_queue</code>使用<code>greater</code>或<code>less</code>的方法如上，要注意<code>priority_queue</code>的<code>less</code>是大顶堆，<code>greater</code>是小顶堆，所以一般都用的是<code>greater</code></p>
</li>
<li><p><strong><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/number-of-different-subsequences-gcds/description/">1819. 序列中不同最大公约数的数目</a></strong></p>
<p>枚举每个可能的数字x，检验x是否是某个子序列的最大公约数</p>
<ul>
<li><p>怎么检验？</p>
<p>要想x是序列An的最大公约数，则An中所有能够整除x的数 的 最大公约数 一定是 x</p>
<blockquote>
<p>如An中只有2x,4x，则不成立，子序列的最大公约数只能是2x</p>
<p>但An中有2x,4x,5x，则成立</p>
</blockquote>
<p>即枚举x后，找出An中的所有可以整除x的数，求他们的gcd是否为x</p>
<p>求<strong>多个数的gcd</strong>，可以将g初始化为0，再依次$$g=gcd(g,a_i)$$</p>
</li>
</ul>
</li>
<li><p><strong><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sentence-similarity-iii/description/">1813. 句子相似性 III</a></strong></p>
<ul>
<li><p><strong>字符串处理</strong>典型题目</p>
</li>
<li><p><strong>双指针</strong>新奇题目</p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sentence-similarity-iii/solutions/2062566/ju-zi-xiang-si-xing-iii-by-leetcode-solu-vjy7/">这篇题解</a>中的字符串分词写法可以记一下</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/finding-the-users-active-minutes/description/">1817. 查找用户活跃分钟数</a></p>
<ul>
<li><p>对于自定义类型，重载关系运算符就是在其类型声明中写一个operator重载函数</p>
</li>
<li><p>但是对于已有类型，如vector，可以写一个<code>cmp()</code>函数，再<code>sort(logs.begin(),logs.end(),cmp);</code>这样调用即可</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;a, vector&lt;<span class="keyword">int</span>&gt; &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a[<span class="number">0</span>]==b[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">1</span>]&lt;b[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> a[<span class="number">0</span>]&lt;b[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意写在类中时要加<code>static</code>声明，表明其是<strong>类的静态函数成员</strong>，这样的函数没有<code>this</code>指针（<strong>一般的函数成员非静态，会有this指针，无法传入<code>sort</code>作为排序函数</strong>）</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u010982765/article/details/79021426">不加<code>static</code>的报错及解决</a></p>
<p>或者将自定义比较函数<code>cmp()</code>写在类外面，也没有<code>this</code>指针</p>
<p>参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/AnnieKim/archive/2011/12/04/2275589.html">恼人的函数指针：指向类成员的指针</a></p>
</li>
</ul>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/smallest-string-with-a-given-numeric-value/">1663. 具有给定数值的最小字符串</a></p>
<p>在string前面添加字符，时间效率：</p>
<p><code>string.append(int count, char c)</code> + <code>reverse</code></p>
<p>&gt;</p>
<p><code>string = char(c) + string</code> </p>
<p><code>string.insert(int position, int count, char c)</code></p>
<p><strong>使用+运算符来拼接字符串比较耗时</strong></p>
</li>
<li><p><strong><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-collisions-of-monkeys-on-a-polygon/description/">6338. 猴子碰撞的方法数</a></strong></p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_24016309/article/details/88585522"><strong>C++快速幂求模</strong></a></p>
<blockquote>
<p>$$a^b$$</p>
<p>降低a的规模：<code>a = a % mode</code></p>
<p>降低b的规模：（若b为偶数）$$a^b=(a^2)^{\frac{b}{2}}$$；（若b为奇数）$$a^b=(a^2)^{\frac{b-1}{2}}\times a$$；再降低a的规模即可</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Mode</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> b, <span class="keyword">long</span> <span class="keyword">long</span> mode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">1</span>;</span><br><span class="line">    a = a % mode;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b % <span class="number">2</span> == <span class="number">1</span>)		<span class="comment">//判断是否是奇数，是奇数的话将多出来的数事先乘如sum</span></span><br><span class="line">            sum = (sum * a) % mode;</span><br><span class="line">        b /= <span class="number">2</span>;</span><br><span class="line">        a = (a * a) % mode;<span class="comment">// 不断的两两合并再取模，减小a和b的规模</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Python等直接用库函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">monkeyMove</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        MOD = <span class="number">10</span> ** <span class="number">9</span> + <span class="number">7</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">pow</span>(<span class="number">2</span>, n, MOD) - <span class="number">2</span>) % MOD</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>1324模式和132模式</strong></p>
<ul>
<li><p><strong><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/132-pattern/description/">456. 132 模式</a></strong></p>
<p>  <strong>单调栈</strong>+预处理</p>
<blockquote>
<p>C++中<a target="_blank" rel="noopener" href="https://www.cnblogs.com/JCpeng/p/15101214.html">multiset容器</a>是STL模板<set>库中一个非常有用的类型，它可以看成一个序列，插入一个数，删除一个数都能够在<code>O(logn)</code>的时间内完成，而且他能时刻<strong>保证序列中的数是有序的</strong>，而且序列中<strong>可以存在重复的数</strong>（而set容器要求两两不同，且不保证有序）。</set></p>
</blockquote>
</li>
<li><p><strong><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-increasing-quadruplets/description/">6340. 统计上升四元组</a></strong></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1mD4y1E7QK">视频题解</a></p>
<p><strong>维护二维前后缀<u>预处理</u>的值</strong></p>
<blockquote>
<p>四元组：<code>(i, j, k, l)</code>满足<code>0 &lt;= i &lt; j &lt; k &lt; l &lt; n</code> 且<code>nums[i] &lt; nums[k] &lt; nums[j] &lt; nums[l]</code></p>
<p>$$O(n^2)$$遍历<code>i</code>和<code>l</code>，<code>j</code>和<code>k</code>通过二维前后缀预处理维护</p>
</blockquote>
<ul>
<li><p>还有种做法是借助132模式的结果，<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-increasing-quadruplets/solutions/2080664/by-destiny-god-4qc6/">题解</a>（非常巧妙）</p>
<blockquote>
<p>但是132模式的数据量是2e5,1324模式的数据量是4k，所以后者可以用n^2^的算法，前者只能nlogn或者n</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong><a target="_blank" rel="noopener" href="https://juejin.cn/post/7195143020050645049/">n1. 寻友之旅</a></strong></p>
<p>  <strong>BFS求最短路径</strong></p>
<p>  很久没遇到忘记了</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_26507799/article/details/89390989">Golang的循环输入</a></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a, b <span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    _, err := fmt.Scan(&amp;a, &amp;b)</span><br><span class="line">    <span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(a + b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/trapping-rain-water/">42. 接雨水</a></strong></p>
<p>  <strong>前后缀预处理</strong></p>
<p>  <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/107792266">参考题解</a></p>
</li>
<li><p><strong><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-coloring-game/description/">1145. 二叉树着色游戏</a></strong></p>
<p>  <strong>二叉树的DFS</strong>+<strong>贪心</strong></p>
<p>  需要一点自己的思考</p>
</li>
<li><p><input disabled type="checkbox">  **<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/house-robber-iv/description/">6346. 打家劫舍 IV</a>**【周赛失利题目】</p>
<p>  <strong>二分+贪心</strong>（check函数需要借助贪心来check）</p>
<p>  虽然上来觉得不单调不能二分，但是这是另一种贪心的题型，<strong>最小化最大值</strong>，属于<strong>值域二分</strong>（另一种感觉可以叫<u>定义域二分</u>）</p>
</li>
<li><p><strong><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-moves-to-reach-target-with-rotations/description/">1210. 穿过迷宫的最少移动次数</a></strong></p>
<p>  <strong>BFS求最短路径</strong></p>
<p>  不同之处是需要多一个维度来表示蛇的方向，其他都大同小异</p>
</li>
<li><p><strong><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/design-authentication-manager/description/">1797. 设计一个验证系统</a></strong></p>
<p>  <strong>一边遍历map一边删除其中的元素</strong></p>
<blockquote>
<p>问题：</p>
<ol>
<li>要使用迭代器完成这件事，不能使用<code>auto</code></li>
<li><code>mp.erase(it);</code>之后<code>it</code>会失效，而<code>mp.erase(it)</code>会返回<code>next(it, 1)</code>，所以要使用<code>it</code>来接住其返回值</li>
</ol>
<p>所以需要像下面这样写，删除的时候不需要<code>it++</code>，没删除的时候需要<code>it++</code></p>
</blockquote>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = mp.<span class="built_in">begin</span>(); it != mp.<span class="built_in">end</span>();)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (it-&gt;second &lt;= currentTime)</span><br><span class="line">    &#123;</span><br><span class="line">        it = mp.<span class="built_in">erase</span>(it);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    it++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/dice-roll-simulation/description/">1223. 掷骰子模拟</a></strong></p>
<p>  dp题，<strong>递推方程刚开始想错了</strong>写了很久（高中排列组合没学好）</p>
<ul>
<li><p>如果出现结果需要对1e9+7取模：</p>
<p>注意可能出现的负数，<strong>要先判断是负数，才能先加再模</strong>，不然可能出现取模之前就会因为加了1e9+7而整数溢出</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">if</span>(dp[i][j]&lt;<span class="number">0</span>)</span><br><span class="line">       dp[i][j]+=<span class="number">1000000007</span>;</span><br><span class="line">dp[i][j]%=<span class="number">1000000007</span>;</span><br></pre></td></tr></table></figure>

<p>  不能这样写！！！有直接溢出的风险！！！</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j]+=<span class="number">1000000007</span>;</span><br><span class="line">dp[i][j]%=<span class="number">1000000007</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><input checked disabled type="checkbox">  **<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-the-number-of-fair-pairs/description/">6355. 统计公平数对的数目</a>**【332周赛第二题】</p>
<p>  二分</p>
<p>  还是尽量用<code>lower_bound()</code>和<code>upper_bound()</code></p>
<ul>
<li><p><strong>因为这俩库函数若找不到，返回的是<code>nums.end()</code>，但手写二分找不到的时候只能返回序列中最后一个元素，最后一个元素可能是不符合要求的，但还是会返回</strong></p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> l=<span class="built_in">lower_bound</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>(),lower)-nums.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">int</span> r=<span class="built_in">upper_bound</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>(),upper)-nums.<span class="built_in">begin</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>如果有不方便使用上述库函数的场景，如需要自己写<code>check()</code>函数，需要手写二分，可以在序列末尾<code>push_back()</code>一个最大的元素，这样可以起到<code>nums.end()</code>的作用</strong></p>
<p>  <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-the-number-of-fair-pairs/submissions/401641036/">参考代码</a></p>
</li>
</ul>
</li>
<li><p><input disabled type="checkbox">  **<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subsequence-with-the-minimum-score/description/">6357. 最少得分子序列</a>**【332周赛第四题】</p>
<p>  字符串处理+<strong>前后缀分解</strong>+查找子串+<strong>预处理</strong></p>
<p>  看<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1GY411i7RP">0x3F</a>的视频题解后<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subsequence-with-the-minimum-score/description/">自己写的代码</a>（因为粗心写了不少bug，主要还是因为代码逻辑太复杂了）</p>
</li>
<li><p><input checked disabled type="checkbox">  **<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/substring-xor-queries/description/">6356. 子字符串异或查询</a>**【332周赛第三题】</p>
<p>  最开始一直TLE，但是仔细看了<strong>题目数据范围</strong>之后，发现可以<strong>将复杂度从n^2^（1e8）优化到（30×30）</strong></p>
<p>  因为有<code>0 &lt;= first_i, second_i &lt;= 10^9</code>，所以结果的范围也是[0, 1e9]，1e9就是（2^10^）^3^，即在二进制字符串表示中只用遍历30bits的长度，所以复杂度可以优化为（30×30）</p>
</li>
<li><p><strong><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/replace-the-substring-for-balanced-string/description/">1234. 替换子串得到平衡字符串</a></strong></p>
<p>  <strong>双指针（滑动窗口）</strong></p>
<p>  <strong><u>双指针的难题比较少见，可以多看看</u></strong></p>
</li>
<li><p><strong><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-well-performing-interval/description/">1124. 表现良好的最长时间段</a></strong></p>
<p>  <strong>前缀和</strong>+哈希</p>
<blockquote>
<p>刚上来想法是双指针，后来发觉不能用</p>
</blockquote>
<p>  算是比较反常规的前缀和了（和560很像）</p>
</li>
<li><p><strong><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-average-pass-ratio/description/">1792. 最大平均通过率</a></strong></p>
<p>  能看出来是用自定义类型的优先队列来做，但是要注意：</p>
<ol>
<li><p>在类内重载运算符的时候，属于类的成员函数，需要隐式地获取第一个参数【<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_37858023/article/details/126581411">参考</a>】</p>
<p>所以要么在函数声明前面加上<code>friend</code>关键字；要么在类的外面声明这个重载函数</p>
</li>
<li><p>本题中的类成员用两个int，即<code>int pass, total;</code></p>
<p>比用一个vector快多了，因为用vector需要经过多次拷贝复制，会卡时间复杂度</p>
</li>
</ol>
</li>
<li><p><strong><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/stone-game-ii/description/">1140. 石子游戏 II</a></strong></p>
<p>  <strong>动态规划==回溯+记忆化搜索</strong></p>
<p>  这题多看看罢</p>
</li>
<li><p><strong><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sort-colors/description/">75. 颜色分类</a></strong></p>
<p>  基本要求好满足，但是进阶要求<code>一个仅使用常数空间的一趟扫描算法</code></p>
<p>  <strong>双指针</strong>（<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sort-colors/solutions/437968/yan-se-fen-lei-by-leetcode-solution/">参考</a>）</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/shortest-unsorted-continuous-subarray/">581. 最短无序连续子数组</a></p>
<p>  要求$$O(n)$$时间求解，要动动脑筋（单调栈可以，但是不知道为啥很慢）</p>
</li>
<li><p><strong>Trie字典树</strong></p>
<p>  标准写法见<a href="https://wan-nan.github.io/2022/07/14/745.%E5%89%8D%E7%BC%80%E5%92%8C%E5%90%8E%E7%BC%80%E6%90%9C%E7%B4%A2%EF%BC%88Trie%E5%86%99%E6%B3%95%EF%BC%89/">我的另一篇文章</a></p>
<ul>
<li><p><strong><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/implement-trie-prefix-tree/description/">208. 实现 Trie (前缀树)</a></strong></p>
<p>  Trie类中包含两个成员，第一个成员是<code>unordered_map&lt;char, Trie*&gt;</code>，即<strong>子节点的值到子节点地址的映射</strong></p>
<p>  第二个成员是子节点的信息，如该节点是否有单词</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line">    <span class="comment">// char c;</span></span><br><span class="line">    unordered_map&lt;<span class="keyword">char</span>,Trie *&gt; mp;</span><br><span class="line">    <span class="keyword">bool</span> flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/replace-words/description/">648. 单词替换</a></p>
<p>  <strong>单独写一个Trie类</strong></p>
<p>  类的声明最后要加<strong>分号</strong></p>
<p>  Search()方法和Insert()方法可以根据题目适当修改</p>
</li>
<li><p><strong><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/design-add-and-search-words-data-structure/description/">211. 添加与搜索单词 - 数据结构设计</a></strong></p>
<p>  unordered_map的Trie树会比直接用数组慢一些</p>
<p>  <strong>一定要先count()再取值！</strong><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_39354847/article/details/111087774">map直接取值可能导致本来不存在的键值被添加进去</a></p>
</li>
</ul>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/course-schedule-ii/description/">210. 课程表 II</a></p>
<p>  拓扑排序</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/add-two-numbers/description">2. 两数相加</a></p>
<p>  按位加法</p>
<p>  顺带写了个翻转链表（后面发现误解了题意，本题不需要翻转）</p>
<p>  <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/fan-zhuan-lian-biao-lcof/">翻转链表题目链接</a></p>
</li>
<li><p><strong><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/triples-with-bitwise-and-equal-to-zero/">982. 按位与为零的三元组</a></strong></p>
<p>  有技巧的枚举 + 常数优化</p>
<p>  将三元组遍历的$$O(n^3)$$复杂度优化到$$O(n^2+C\times n)$$，其中 n 是数组 $$\textit{nums}$$ 的长度，C 是数组 $$\textit{nums}$$ 中的元素范围，在本题中 $$C = 2^{16}$$</p>
</li>
<li><p><strong><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/median-of-two-sorted-arrays/description">4. 寻找两个正序数组的中位数</a></strong></p>
<p>  思路不常见的<strong>二分</strong>，挺好的题</p>
<p>  <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/median-of-two-sorted-arrays/solutions/258842/xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-s-114/">官方题解的视频</a>讲的很好</p>
</li>
<li><p><strong><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/brace-expansion-ii/description/">1096. 花括号展开 II</a></strong></p>
<p>  用栈计算表达式的题目，比较经典</p>
<blockquote>
<p>与求解中缀表达式一样，在遍历表达式的过程中我们需要用到两个栈，一个用来存放运算符（即加号和乘号，以及左大括号），另一个用来存运算对象（即集合）。</p>
</blockquote>
<p>  <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/container/map/merge">合并两个set</a>（和求并集不太相同）：<code>std::map&lt;Key,T,Compare,Allocator&gt;::merge</code></p>
<p>  <code>set1.merge(set2);</code></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/make-sum-divisible-by-p/description/">1590. 使数组和能被 P 整除</a></p>
<p>  这题是<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/two-sum/">1. 两数之和</a>的plus版</p>
<p>  前缀和+哈希（一时间觉得需要$$O(n^2)$$的复杂度无从下手，就是前缀和+哈希）</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/split-two-strings-to-make-palindrome/description/">1616. 分割两个字符串得到回文串</a></p>
<p>  双指针 还不错的题</p>
</li>
<li><p><strong><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/adding-two-negabinary-numbers/description/">1073. 负二进制数相加</a></strong></p>
<p>  模拟加法</p>
<ul>
<li><p>与大数加法不同的是，这题需要重新推导进位等值的计算规则，但思路都相同</p>
<p>如果暴力，会超过long的限制，整数溢出($$2^{1000}$$需要1000位整型来的存储，但long long只有64bits)</p>
</li>
<li><p>以负数为基数的短除法，要确保余数为正，可以在取余后进行判断，如果余数是负，则余数-=基数（基数为负），同时商+=1；或余数+=基数（基数为正），同时商-=1。</p>
</li>
</ul>
<p>  C++vector的截取，使用<strong>迭代器的初始化，或assign迭代器</strong></p>
</li>
<li><p><strong><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/letter-tile-possibilities/description/">1079. 活字印刷</a></strong></p>
<p>  看了tag才想起来做法</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-sum-bst-in-binary-tree/description/">1373. 二叉搜索子树的最大键值和</a></p>
<p>  后序遍历</p>
<p>  能自己写出来，但是效率比较低，不论是写代码的效率还是代码的效率</p>
<p>  经历了两次优化：</p>
<ul>
<li><p>第一次：（回溯中需要返回比较多的信息时）新定义了结构体用来传输返回值，同时使得代码可读性提高（不再是vector数组下标来存，而是带有名称的字段）</p>
<p>C++中定义结构体不需要<code>typedef</code>，只需要</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span>&#123;</span></span><br><span class="line">	string name;</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">	<span class="keyword">bool</span> gender;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>即可。使用时<code>person Donald= &#123;&quot;Trump&quot;, 76, ture&#125;;</code></p>
</li>
<li><p>第二次：简化逻辑，减少不必要的分支判断</p>
</li>
</ul>
</li>
<li><p><strong><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/o8SXZn/description/">LCP 33. 蓄水</a></strong></p>
<p>  枚举，搞清楚变量之间的关系之后就可以枚举</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/insufficient-nodes-in-root-to-leaf-paths/description/">1080. 根到叶路径上的不足节点</a></p>
<p>  后序遍历</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/odd-string-difference/description/">2451. 差值数组不同的字符串</a></p>
<p>  标准库容器支持关系运算符，<u>比较两个 vector 是否相等使用 <strong>== 运算符</strong>即可</u>。 当两个 vector 包含相同个数的元素，且对位元素都相等时，判定两个 vector 相等，否则不等。</p>
</li>
<li><p><strong><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/shortest-path-in-binary-matrix/description/">1091. 二进制矩阵中的最短路径</a></strong></p>
<p>  这题我上来第一反应居然是用DFS，这题是<strong>BFS最常见的应用：迷宫问题-寻找最短路径</strong></p>
<p>  储存坐标时使用<code>pair&lt;int,int&gt;</code>比使用<code>vector&lt;int&gt;</code>快很多很多</p>
<p>  <strong>如果问题需要枚举所有方案，才需要DFS</strong></p>
</li>
<li><p><strong><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-cost-tree-from-leaf-values/description/">1130. 叶值的最小代价生成树</a></strong></p>
<p>  标准的<strong>区间dp</strong>，复杂度为$$O(n^3)$$</p>
<p>  注意不要漏掉“数组 <code>arr</code> 中的值与树的中序遍历中每个叶节点的值一一对应”的条件</p>
</li>
<li><p><input disabled type="checkbox">  ==<strong><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-subarray/description/">53. 最大子数组和</a></strong>==</p>
<p>  动态规划：时间复杂度$O(n)$，空间复杂度$O(1)$</p>
<p>  <strong><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-subarray-sum-with-one-deletion/description/">1186. 删除一次得到子数组最大和</a></strong></p>
<ul>
<li><p>动态规划：时间复杂度$O(n)$，空间复杂度$O(n)$【我的方法：两边延伸最大子数组和】</p>
</li>
<li><p>动态规划：时间复杂度$O(n)$，空间复杂度$O(1)$【官解方法：一遍遍历+$O(1)$空间（分是否删除过的两种情况进行讨论）】</p>
</li>
</ul>
</li>
<li><p><strong><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/kth-largest-element-in-an-array/description">215. 数组中的第K个最大元素</a></strong></p>
<p>  基于快速排序的选择方法</p>
<p>  ==<strong>快速排序</strong>都不会写啦？？==快速排序笔记详见<a href="https://wan-nan.github.io/2021/07/19/AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%AC%94%E8%AE%B0/#:~:text=%E5%A4%8D%E6%9D%82%E5%BA%A6nlogn%E3%80%82-,%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E2%80%94%E2%80%94%E5%88%86%E6%B2%BB,-%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B%EF%BC%9A">这里</a></p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> q[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>, x = q[l + r &gt;&gt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> i ++ ; <span class="keyword">while</span> (q[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j -- ; <span class="keyword">while</span> (q[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span>(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">quick_sort</span>(q, l, j), <span class="built_in">quick_sort</span>(q, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><input disabled type="checkbox"> </p>
</li>
</ul>
</div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>wan_nan</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="https://wan-nan.github.io/2022/10/29/LEETCODE-TOP100/" title="LEETCODE">https://wan-nan.github.io/2022/10/29/LEETCODE-TOP100/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本博客所有文章除特别声明外，均默认采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><svg class="icon"><use xlink:href="#icon-creative-commons-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-by-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-nc-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-sa-line"></use></svg></a> 许可协议。</li></ul></section></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/2022/11/06/C++%E5%AD%A6%E4%B9%A0/" rel="prev" title="C++学习"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-left-s-line"></use></svg><span class="post-nav-text">C++学习</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/2022/10/16/ns-3%E5%AD%A6%E4%B9%A0/" rel="next" title="ns-3学习"><span class="post-nav-text">ns-3学习</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-right-s-line"></use></svg></a></div></div></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2021 – 2023 </span><span class="with-love" id="animate"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-cloud-line"></use></svg></span><span class="author"> wan_nan</span></div><div class="live_time"><span>本博客已悄悄运行</span><span id="display_live_time"></span><span class="moe-text">(●'◡'●)</span><script>function blog_live_time() {
  setTimeout(blog_live_time, 1000);
  const start = new Date('2021-07-03T00:00:00');
  const now = new Date();
  const timeDiff = (now.getTime() - start.getTime());
  const msPerMinute = 60 * 1000;
  const msPerHour = 60 * msPerMinute;
  const msPerDay = 24 * msPerHour;
  const passDay = Math.floor(timeDiff / msPerDay);
  const passHour = Math.floor((timeDiff % msPerDay) / 60 / 60 / 1000);
  const passMinute = Math.floor((timeDiff % msPerHour) / 60 / 1000);
  const passSecond = Math.floor((timeDiff % msPerMinute) / 1000);
  display_live_time.innerHTML = " " + passDay + " 天 " + passHour + " 小时 " + passMinute + " 分 " + passSecond + " 秒";
}
blog_live_time();
</script></div><div id="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv" title="总访客量"><span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-user-line"></use></svg></span><span id="busuanzi_value_site_uv"></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv" title="总访问量"><span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-eye-line"></use></svg></span><span id="busuanzi_value_site_pv"></span></span></div></footer><a class="hty-icon-button" id="back-to-top" aria-label="back-to-top" href="#"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-up-s-line"></use></svg><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#0078E7" stroke-width="2" stroke-linecap="round"></circle></svg></a><div class="aplayer no-destroy" id="aplayer" data-id="8293178209" data-server="tencent" data-type="playlist" data-fixed="true" data-theme="#0078E7" data-loop="all" data-order="list" data-preload="auto" data-volume="0.7" data-mutex data-lrctype="0" data-listmaxheight="340px" data-storagename="metingjs"></div></div></body></html>