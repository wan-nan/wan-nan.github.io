<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#0078E7"><meta name="author" content="wan_nan"><meta name="copyright" content="wan_nan"><meta name="generator" content="Hexo 5.4.0"><meta name="theme" content="hexo-theme-yun"><title>冲！ | 风物</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/star-markdown-css@0.1.25/dist/yun/yun-markdown.min.css"><script src="//at.alicdn.com/t/font_1140697_dxory92pb0h.js" async></script><script src="https://cdn.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>document.addEventListener("DOMContentLoaded", () => {
  [".post-card",".post-content img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
});
</script><link class="aplayer-style-marker" rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script class="aplayer-script-marker" src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" defer></script><script class="meting-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js" defer></script><link rel="icon" href="/dino.png"><link rel="mask-icon" href="/dino.png" color="#0078E7"><link rel="alternate icon" href="/yun.ico"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="preload" href="/js/utils.js" as="script"><link rel="preload" href="/js/hexo-theme-yun.js" as="script"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><script id="yun-config">
    const Yun = window.Yun || {};
    window.CONFIG = {"hostname":"wan-nan.github.io","root":"/","title":"风物的小站","version":"1.6.1","mode":"auto","copycode":true,"page":{"isPost":true},"i18n":{"placeholder":"搜索...","empty":"找不到您查询的内容: ${query}","hits":"找到 ${hits} 条结果","hits_time":"找到 ${hits} 条结果（用时 ${time} 毫秒）"},"anonymous_image":"https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/avatar/none.jpg","say":{"api":"https://el-bot-api.vercel.app/api/words/young"},"fireworks":{"colors":["102, 167, 221","62, 131, 225","33, 78, 194"]}};
  </script><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script src="/js/utils.js"></script><script src="/js/hexo-theme-yun.js"></script><link rel="preconnect" href="https://www.google-analytics.com" crossorigin><script async src="https://www.googletagmanager.com/gtag/js?id=G-1LL0D86CY9"></script><script>if (CONFIG.hostname === location.hostname) {
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-1LL0D86CY9');
}</script><script data-ad-client="ca-pub-2245427233262012" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(function(){
  var bp = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  if (curProtocol === 'https') {
    bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else {
    bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(bp, s);
})();</script><!-- Google Tag Manager --><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src='https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','GTM-M9KWR9L');</script><!-- End Google Tag Manager --><meta name="description" content="计算机保研材料及内容整理   文书（个人陈述等等）  英语！！  一些注意事项 填写申请系统的时候“备注”栏千万不可以空缺 数学（线代&gt;概率论&gt;&#x3D;离散&gt;高数）&#x3D;&#x3D; 数据结构&gt;操作系统&gt;计算机网络&gt;程序设计语言(C++,JAVA,PYTHON)&gt;数据库&gt;计组&gt;&gt;思政&gt;&gt;&gt;&gt;其他  项目  Cobb的深度学习部分 模型">
<meta property="og:type" content="article">
<meta property="og:title" content="冲！">
<meta property="og:url" content="https://wan-nan.github.io/2022/07/15/%E5%86%B2%EF%BC%81/index.html">
<meta property="og:site_name" content="风物">
<meta property="og:description" content="计算机保研材料及内容整理   文书（个人陈述等等）  英语！！  一些注意事项 填写申请系统的时候“备注”栏千万不可以空缺 数学（线代&gt;概率论&gt;&#x3D;离散&gt;高数）&#x3D;&#x3D; 数据结构&gt;操作系统&gt;计算机网络&gt;程序设计语言(C++,JAVA,PYTHON)&gt;数据库&gt;计组&gt;&gt;思政&gt;&gt;&gt;&gt;其他  项目  Cobb的深度学习部分 模型">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://wan-nan.github.io/2022/07/15/%E5%86%B2%EF%BC%81/image-20220718200627803.png">
<meta property="og:image" content="https://wan-nan.github.io/2022/07/15/%E5%86%B2%EF%BC%81/image-20220718201555357.png">
<meta property="og:image" content="https://wan-nan.github.io/2022/07/15/%E5%86%B2%EF%BC%81/image-20220718173833528.png">
<meta property="og:image" content="https://github.com/Wulingtian/ANCIS-Pytorch/raw/master/imgs/fig2.png">
<meta property="og:image" content="https://wan-nan.github.io/2022/07/15/%E5%86%B2%EF%BC%81/image-20220718154322712.png">
<meta property="og:image" content="https://wan-nan.github.io/2022/07/15/%E5%86%B2%EF%BC%81/image-20220718172611580.png">
<meta property="og:image" content="https://wan-nan.github.io/2022/07/15/%E5%86%B2%EF%BC%81/image-20220718172926592.png">
<meta property="og:image" content="https://wan-nan.github.io/2022/07/15/%E5%86%B2%EF%BC%81/image-20220908202701739.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210321102547844.png">
<meta property="og:image" content="https://wan-nan.github.io/2022/07/15/%E5%86%B2%EF%BC%81/image-20220830155745130.png">
<meta property="og:image" content="https://pica.zhimg.com/80/b259fa0961ec56550ceec43e6d5899fd_720w.jpg">
<meta property="og:image" content="https://wan-nan.github.io/2022/07/15/%E5%86%B2%EF%BC%81/image-20220830184519403.png">
<meta property="og:image" content="https://wan-nan.github.io/2022/07/15/%E5%86%B2%EF%BC%81/image-20220830185251321.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201203201211489.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201203201234972.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201203201303948.png">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS80ZjIxOGE0Zi1iNGYzLTQwZTEtOWM0Mi0yYTIwNjMyMGY5YmEucG5n?x-oss-process=image/format,png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210321102547844.png">
<meta property="og:image" content="https://wan-nan.github.io/2022/07/15/%E5%86%B2%EF%BC%81/image-20220904185842790.png">
<meta property="og:image" content="https://wan-nan.github.io/2022/07/15/%E5%86%B2%EF%BC%81/image-20220904190411479.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/eb2c7ddfd4d54e3faa1edc4f16d01267.png">
<meta property="og:image" content="https://wan-nan.github.io/2022/07/15/%E5%86%B2%EF%BC%81/image-20220904164155297.png">
<meta property="og:image" content="https://wan-nan.github.io/2022/07/15/%E5%86%B2%EF%BC%81/image-20220904164310623.png">
<meta property="og:image" content="https://wan-nan.github.io/2022/07/15/%E5%86%B2%EF%BC%81/image-20220904164911764.png">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-2f535e26b4a54ca73a3e7c136b004f8f_720w.jpg">
<meta property="og:image" content="https://wan-nan.github.io/2022/07/15/%E5%86%B2%EF%BC%81/image-20220904192625535.png">
<meta property="og:image" content="https://wan-nan.github.io/2022/07/15/%E5%86%B2%EF%BC%81/image-20220904200407027.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/22ad737da296f679688ada95924a6b01.png">
<meta property="og:image" content="https://wan-nan.github.io/2022/07/15/%E5%86%B2%EF%BC%81/image-20220904200802135.png">
<meta property="og:image" content="https://wan-nan.github.io/2022/07/15/%E5%86%B2%EF%BC%81/image-20220904201409888.png">
<meta property="og:image" content="https://wan-nan.github.io/2022/07/15/%E5%86%B2%EF%BC%81/image-20220904201506836.png">
<meta property="og:image" content="https://wan-nan.github.io/2022/07/15/%E5%86%B2%EF%BC%81/image-20220904201651850.png">
<meta property="og:image" content="https://wan-nan.github.io/2022/07/15/%E5%86%B2%EF%BC%81/image-20220904201742044.png">
<meta property="og:image" content="https://wan-nan.github.io/2022/07/15/%E5%86%B2%EF%BC%81/image-20220904201851430.png">
<meta property="og:image" content="https://wan-nan.github.io/2022/07/15/%E5%86%B2%EF%BC%81/image-20220904202110648.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210205152509698.png">
<meta property="og:image" content="https://wan-nan.github.io/2022/07/15/%E5%86%B2%EF%BC%81/image-20220718205628921.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/d6d79380aeee4d95935047201400438e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAd2FuX25hbg==,size_20,color_FFFFFF,t_70,g_se,x_16">
<meta property="og:image" content="https://img-blog.csdn.net/20160126223713317">
<meta property="og:image" content="https://wan-nan.github.io/2022/07/15/%E5%86%B2%EF%BC%81/image-20220809171532514.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/565cb4037b334682bee06def7c557e0e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAd2FuX25hbg==,size_20,color_FFFFFF,t_70,g_se,x_16">
<meta property="og:image" content="https://img-blog.csdnimg.cn/3ece21be6086485a8d01bf92c492d956.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAd2FuX25hbg==,size_20,color_FFFFFF,t_70,g_se,x_16">
<meta property="og:image" content="https://wan-nan.github.io/2022/07/15/%E5%86%B2%EF%BC%81/image-20220826112318178.png">
<meta property="og:image" content="https://wan-nan.github.io/2022/07/15/%E5%86%B2%EF%BC%81/image-20220826160421231.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190414101321191.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2019041418290822.png">
<meta property="og:image" content="https://wan-nan.github.io/2022/07/15/%E5%86%B2%EF%BC%81/image-20220911185915020.png">
<meta property="og:image" content="https://wan-nan.github.io/2022/07/15/%E5%86%B2%EF%BC%81/image-20220911182123606.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/add52a60dd1b4b3cae5adcd235f351d0.png">
<meta property="og:image" content="https://wan-nan.github.io/2022/07/15/%E5%86%B2%EF%BC%81/image-20220911175911332.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/28f9a7a0e6b74623928abd0f888075e5.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAd2FuX25hbg==,size_20,color_FFFFFF,t_70,g_se,x_16">
<meta property="og:image" content="https://img-blog.csdnimg.cn/a4da6dc758cd48708db11b4eae230f56.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAd2FuX25hbg==,size_20,color_FFFFFF,t_70,g_se,x_16">
<meta property="og:image" content="https://wan-nan.github.io/2022/07/15/%E5%86%B2%EF%BC%81/image-20220911171652186.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/7be01f4ccb4c4227a2121c7c31721470.png">
<meta property="og:image" content="https://wan-nan.github.io/2022/07/15/%E5%86%B2%EF%BC%81/image-20220911183110970.png">
<meta property="og:image" content="https://wan-nan.github.io/2022/07/15/%E5%86%B2%EF%BC%81/image-20220911185601949.png">
<meta property="og:image" content="https://wan-nan.github.io/2022/07/15/%E5%86%B2%EF%BC%81/image-20220820162711917.png">
<meta property="og:image" content="https://wan-nan.github.io/2022/07/15/%E5%86%B2%EF%BC%81/image-20220820183420206.png">
<meta property="og:image" content="https://wan-nan.github.io/2022/07/15/%E5%86%B2%EF%BC%81/image-20220531152151227.png">
<meta property="og:image" content="https://wan-nan.github.io/2022/07/15/%E5%86%B2%EF%BC%81/image-20220820183258815.png">
<meta property="og:image" content="https://wan-nan.github.io/2022/07/15/%E5%86%B2%EF%BC%81/image-20220820183638023.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190414095710259.png">
<meta property="og:image" content="https://wan-nan.github.io/2022/07/15/%E5%86%B2%EF%BC%81/image-20220628211819822.png">
<meta property="og:image" content="https://wan-nan.github.io/2022/07/15/%E5%86%B2%EF%BC%81/image-20220628211847524.png">
<meta property="og:image" content="https://wan-nan.github.io/2022/07/15/%E5%86%B2%EF%BC%81/image-20220628211908776.png">
<meta property="og:image" content="https://wan-nan.github.io/2022/07/15/%E5%86%B2%EF%BC%81/image-20220628211950071.png">
<meta property="og:image" content="https://wan-nan.github.io/2022/07/15/%E5%86%B2%EF%BC%81/image-20220628212250572.png">
<meta property="og:image" content="https://wan-nan.github.io/2022/07/15/%E5%86%B2%EF%BC%81/image-20220628212657748.png">
<meta property="og:image" content="https://wan-nan.github.io/2022/07/15/%E5%86%B2%EF%BC%81/image-20220908090846844.png">
<meta property="og:image" content="https://wan-nan.github.io/2022/07/15/%E5%86%B2%EF%BC%81/image-20220908091311359.png">
<meta property="og:image" content="https://wan-nan.github.io/2022/07/15/%E5%86%B2%EF%BC%81/image-20220907165028801.png">
<meta property="og:image" content="https://wan-nan.github.io/2022/07/15/%E5%86%B2%EF%BC%81/image-20220907223019664.png">
<meta property="og:image" content="https://wan-nan.github.io/2022/07/15/%E5%86%B2%EF%BC%81/image-20220918211341161.png">
<meta property="og:image" content="https://wan-nan.github.io/2022/07/15/%E5%86%B2%EF%BC%81/image-20220908092425614.png">
<meta property="og:image" content="https://wan-nan.github.io/2022/07/15/%E5%86%B2%EF%BC%81/image-20220908101841943.png">
<meta property="og:image" content="https://wan-nan.github.io/2022/07/15/%E5%86%B2%EF%BC%81/image-20220908102301715.png">
<meta property="og:image" content="https://wan-nan.github.io/2022/07/15/%E5%86%B2%EF%BC%81/image-20220908091630233.png">
<meta property="og:image" content="https://wan-nan.github.io/2022/07/15/%E5%86%B2%EF%BC%81/image-20220908161117663.png">
<meta property="og:image" content="https://img-blog.csdn.net/20180508210408944">
<meta property="og:image" content="https://img-blog.csdn.net/20180508210518867">
<meta property="og:image" content="https://wan-nan.github.io/2022/07/15/%E5%86%B2%EF%BC%81/image-20220908092113399.png">
<meta property="og:image" content="https://wan-nan.github.io/2022/07/15/%E5%86%B2%EF%BC%81/image-20220908150609272.png">
<meta property="og:image" content="https://wan-nan.github.io/2022/07/15/%E5%86%B2%EF%BC%81/image-20220908153317026.png">
<meta property="og:image" content="https://wan-nan.github.io/2022/07/15/%E5%86%B2%EF%BC%81/image-20220908155205564.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/cb718bd44a2f433c9d93b7ccb595ff04.png">
<meta property="og:image" content="https://wan-nan.github.io/2022/07/15/%E5%86%B2%EF%BC%81/image-20220908160330976.png">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/18464438-51a047178ff21028.png">
<meta property="og:image" content="https://wan-nan.github.io/2022/07/15/%E5%86%B2%EF%BC%81/image-20220715193229538.png">
<meta property="article:published_time" content="2022-07-15T11:23:25.000Z">
<meta property="article:modified_time" content="2022-09-19T07:52:07.972Z">
<meta property="article:author" content="wan_nan">
<meta property="article:tag" content="学习">
<meta property="article:tag" content="daily">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://wan-nan.github.io/2022/07/15/%E5%86%B2%EF%BC%81/image-20220718200627803.png"><script src="/js/ui/mode.js"></script></head><body><script defer src="https://cdn.jsdelivr.net/npm/animejs@latest"></script><script defer src="/js/ui/fireworks.js"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/js/sidebar.js"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="文章目录"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-list-ordered"></use></svg></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="站点概览"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-passport-line"></use></svg></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about/" title="wan_nan"><img width="96" loading="lazy" src="/images/avatar.jpg" alt="wan_nan"><span class="site-author-status" title="sleeping">😴</span></a><div class="site-author-name"><a href="/about/">wan_nan</a></div><span class="site-name">风物</span><sub class="site-subtitle">Yeah!</sub><div class="site-desciption">个人博客</div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="首页"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-home-4-line"></use></svg></span></a><div class="site-state-item"><a href="/archives/" title="归档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-archive-line"></use></svg></span><span class="site-state-item-count">42</span></a></div><div class="site-state-item"><a href="/categories/" title="分类"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-2-line"></use></svg></span><span class="site-state-item-count">3</span></a></div><div class="site-state-item"><a href="/tags/" title="标签"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="site-state-item-count">38</span></a></div><a class="site-state-item hty-icon-button" href="/about/#comment" title="留言板"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-clipboard-line"></use></svg></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="http://wpa.qq.com/msgrd?v=3&amp;uin=2213324970&amp;site=qq&amp;menu=yes" title="QQ" target="_blank" style="color:#12B7F5"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-qq-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/wan-nan" title="GitHub" target="_blank" style="color:#181717"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-github-line"></use></svg></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-contrast-2-line"></use></svg></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.</span> <span class="toc-text">一些注意事项</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE"><span class="toc-number"></span> <span class="toc-text">项目</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#CobbPredict"><span class="toc-number"></span> <span class="toc-text">CobbPredict</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%83%A8%E7%BD%B2"><span class="toc-number">1.</span> <span class="toc-text">部署</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF"><span class="toc-number">2.</span> <span class="toc-text">前端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8E%E7%AB%AF"><span class="toc-number">3.</span> <span class="toc-text">后端</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E9%83%A8%E5%88%86"><span class="toc-number">3.1.</span> <span class="toc-text">数据库部分</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9E%8B"><span class="toc-number">4.</span> <span class="toc-text">模型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B4%AA%E5%90%83%E8%9B%87"><span class="toc-number"></span> <span class="toc-text">贪吃蛇</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%BA%E8%AF%95"><span class="toc-number"></span> <span class="toc-text">机试</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%8B%B1%E8%AF%AD"><span class="toc-number"></span> <span class="toc-text">英语</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Sorry-Can-you-pardon-it-again"><span class="toc-number">1.</span> <span class="toc-text">Sorry,Can you pardon it again?</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E9%97%AE%E6%A6%82%E5%BF%B5%E9%A2%98"><span class="toc-number">1.1.</span> <span class="toc-text">主要问概念题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number"></span> <span class="toc-text">数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%AA%E8%AE%BA"><span class="toc-number">1.</span> <span class="toc-text">绪论</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8"><span class="toc-number">2.</span> <span class="toc-text">线性表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97"><span class="toc-number">3.</span> <span class="toc-text">栈和队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B2"><span class="toc-number">4.</span> <span class="toc-text">串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">5.</span> <span class="toc-text">树与二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE"><span class="toc-number">6.</span> <span class="toc-text">图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE"><span class="toc-number">7.</span> <span class="toc-text">查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F"><span class="toc-number">8.</span> <span class="toc-text">排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E7%8E%87%E8%AE%BA"><span class="toc-number"></span> <span class="toc-text">概率论</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0"><span class="toc-number"></span> <span class="toc-text">机器学习</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E5%8E%9F"><span class="toc-number"></span> <span class="toc-text">组原</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%BD%91"><span class="toc-number"></span> <span class="toc-text">计网</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82"><span class="toc-number">1.</span> <span class="toc-text">应用层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E8%BE%93%E5%B1%82"><span class="toc-number">2.</span> <span class="toc-text">传输层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82"><span class="toc-number">3.</span> <span class="toc-text">网络层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82"><span class="toc-number">4.</span> <span class="toc-text">数据链路层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98"><span class="toc-number">5.</span> <span class="toc-text">问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number"></span> <span class="toc-text">数据库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number"></span> <span class="toc-text">操作系统</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%A1%E7%A8%8B"><span class="toc-number">0.1.</span> <span class="toc-text">管程</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9D%90%E6%96%99"><span class="toc-number"></span> <span class="toc-text">材料</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%99%84%E5%BD%95"><span class="toc-number"></span> <span class="toc-text">附录</span></a></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="hty-card post-block" itemscope itemtype="https://schema.org/Article"><link itemprop="mainEntityOfPage" href="https://wan-nan.github.io/2022/07/15/%E5%86%B2%EF%BC%81/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="wan_nan"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="风物"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">冲！</h1><div class="post-meta"><div class="post-time" style="display:block"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-line"></use></svg></span> <time title="创建时间：2022-07-15 19:23:25" itemprop="dateCreated datePublished" datetime="2022-07-15T19:23:25+08:00">2022-07-15</time><span class="post-meta-divider">-</span><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-2-line"></use></svg></span> <time title="修改时间：2022-09-19 15:52:07" itemprop="dateModified" datetime="2022-09-19T15:52:07+08:00">2022-09-19</time></div><span class="post-count"><span class="post-symbolcount"><span class="post-meta-item-icon" title="本文字数"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-file-word-line"></use></svg></span> <span title="本文字数">13.5k</span><span class="post-meta-divider">-</span><span class="post-meta-item-icon" title="阅读时长"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-timer-line"></use></svg></span> <span title="阅读时长">50m</span></span></span><span class="post-busuanzi"><span class="post-meta-divider">-</span><span class="post-meta-item-icon" title="阅读次数"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-eye-line"></use></svg> <span id="busuanzi_value_page_pv"></span></span></span><div class="post-classify"><span class="post-category"> <span class="post-meta-item-icon" style="margin-right:3px;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-line"></use></svg></span><span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a class="category-item" href="/categories/%E7%AC%94%E8%AE%B0/" style="--text-color:dimgray" itemprop="url" rel="index"><span itemprop="text">笔记</span></a></span></span><span class="post-tag"><span class="post-meta-divider">-</span><a class="tag-item" href="/tags/%E5%AD%A6%E4%B9%A0/" style="--text-color:saddlebrown"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">学习</span></a><a class="tag-item" href="/tags/daily/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">daily</span></a></span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body" style="--smc-primary:#0078E7;"><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/541112698">计算机保研材料及内容整理</a></p>
<ul>
<li><input disabled type="checkbox"> 文书（个人陈述等等）</li>
<li><input disabled type="checkbox"> 英语！！</li>
</ul>
<h3 id="一些注意事项"><a href="#一些注意事项" class="headerlink" title="一些注意事项"></a><strong>一些注意事项</strong></h3><blockquote>
<p>填写申请系统的时候“备注”栏千万不可以空缺</p>
<p>数学（线代&gt;概率论&gt;=离散&gt;高数）== 数据结构&gt;操作系统&gt;计算机网络&gt;程序设计语言(C++,JAVA,PYTHON)&gt;数据库&gt;计组&gt;&gt;思政&gt;&gt;&gt;&gt;其他</p>
</blockquote>
<h1 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h1><ul>
<li><input checked disabled type="checkbox"> Cobb的深度学习部分 模型相关的代码 例如：使用了什么优化器</li>
<li><input disabled type="checkbox"> 计网</li>
<li><input disabled type="checkbox"> 贪吃蛇</li>
<li><input disabled type="checkbox"> </li>
</ul>
<h2 id="CobbPredict"><a href="#CobbPredict" class="headerlink" title="CobbPredict"></a>CobbPredict</h2><ul>
<li><p><input checked disabled type="checkbox">  代码量（各个部分都要分开统计）：接近4k行代码</p>
<ul>
<li><p>后端：1281行（Python）</p>
<img src="/2022/07/15/%E5%86%B2%EF%BC%81/image-20220718200627803.png" class title="image-20220718200627803" loading="lazy"></li>
<li><p>前端：2365行（Vue）+141（JavaScript）</p>
<img src="/2022/07/15/%E5%86%B2%EF%BC%81/image-20220718201555357.png" class title="image-20220718201555357" loading="lazy"></li>
</ul>
</li>
<li><p><input checked disabled type="checkbox">  网络怎么连通的（Frp）</p>
</li>
</ul>
<h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p>原理（文档）：<a target="_blank" rel="noopener" href="https://gofrp.org/docs/examples/vhost-http/">通过自定义域名访问内网的 Web 服务</a></p>
<p>操作（步骤）：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/f934e6f76673">使用Frp内网穿透访问内网Web项目</a></p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/276309837">内网穿透的原理</a></p>
<h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><p>Vue+JavaScript+Axios+element-ui</p>
<h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u011240016/article/details/70889260">Flask程序的基本结构</a></p>
<h4 id="数据库部分"><a href="#数据库部分" class="headerlink" title="数据库部分"></a>数据库部分</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_38088298/article/details/80802819">Flask连接本地mysql写法</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_36381573/article/details/83188851">手动创建数据库后在flask中连接</a></p>
<ul>
<li><p>一共两张表，如下图所示：</p>
<img src="/2022/07/15/%E5%86%B2%EF%BC%81/image-20220718173833528.png" class title="image-20220718173833528" loading="lazy">

<ul>
<li>一张表<code>Users</code>，存储用户名和密码，主码是用户名</li>
<li>一张表<code>PatientImg</code>，存储患者信息，主码是imgPath（因为考虑到同一个患者也可能多次使用平台，所以用路径作为主码，且表名也是“PatientImg”），username为外码reference username in Users<ul>
<li>图片放在本机服务器上，用字符串的方式在数据库中存储其路径</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><p>ISBI2020</p>
<p><a target="_blank" rel="noopener" href="https://github.com/yijingru/Vertebra-Landmark-Detection">使用的模型源码</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/31852747">ResNet介绍</a></p>
<ul>
<li><p>Our vertebra-focused（椎骨聚焦） landmark detection network is illustrated in Fig. 2. The inputs of the network are gray-scale images with size fixed to 1024×512. First, we use ResNet34 conv1-5 to extract the high-level semantic features（语义特征） of the input image. Then we use the <a target="_blank" rel="noopener" href="https://www.analyticsvidhya.com/blog/2021/08/all-you-need-to-know-about-skip-connections/">skip connections</a> to combine the deep features with the shallow ones to exploit（利用） both high-level semantic information and low-level fine details（细节）, similar to [16, 17].</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_62311817/article/details/126064158">卷积神经网络之“浅层特征”与“深层特征”</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/460234735">两种特征融合Concat与add的区别</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/xys430381_1/article/details/88355956">深度特征融合—理解add和concat之多层特征融合</a>：add可以认为是特殊的concat形式。但是add的计算量要比concat的计算量小得多</p>
<p><strong>“使用skip connection将深层特征与浅层特征结合起来，以利用高级语义信息和低级精细细节”</strong></p>
<p>上采样采用的方式是<strong>bilinear interpolation双线性插值</strong>（用矩形边界点的值来计算矩形中任意一个点的值）</p>
<ul>
<li><p>具体特征融合的方式可以看下图<strong>类比</strong>理解：</p>
<img src="https://github.com/Wulingtian/ANCIS-Pytorch/raw/master/imgs/fig2.png" alt="img" style="zoom: 25%;" loading="lazy"></li>
<li><p>最后面就是<strong>三个卷积层</strong>来实现</p>
</li>
</ul>
</blockquote>
<p> At layer D2, we construct the heatmap, center offset and corner offset maps using <strong>convolutional layers</strong> for landmark localization.</p>
<img src="/2022/07/15/%E5%86%B2%EF%BC%81/image-20220718154322712.png" class title="image-20220718154322712" loading="lazy">

<p>D2层是256×128×64，经过卷积层调整channels的个数，经过卷积层得到三种输出</p>
<ul>
<li><p>channels=1为<code>heatmap</code>，1维的表示二维图像中的每个像素点是否（0/1）是椎骨中心</p>
<p>【<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/122542747"><strong>focal loss</strong>作为损失函数解决正负样本不均衡</a>】</p>
</li>
<li><p>channels=2为<code>Center Offset</code>，2维的表示二维图像中中心点坐标的偏移 (dx,dy)</p>
<p>【L1 loss】</p>
</li>
<li><p>channels=8为<code>Corner Offset</code>，8维的表示每个椎骨的四个landmark的偏移 (dx,dy)</p>
<p>【L1 loss】</p>
</li>
</ul>
</li>
<li><p>网络结构：</p>
<p><code>base_network</code>是resnet34</p>
<p><code>dec_net</code>即为上面的示意图中的后面的卷积层部分，包含上述三个部分</p>
<img src="/2022/07/15/%E5%86%B2%EF%BC%81/image-20220718172611580.png" class title="image-20220718172611580" loading="lazy">

<ul>
<li><p>将骨干网络<code>base_network</code>提取出的特征送入<code>dec_net</code>三个不同的卷积层网络中，进行上述三个结果的预测</p>
<img src="/2022/07/15/%E5%86%B2%EF%BC%81/image-20220718172926592.png" class title="image-20220718172926592" loading="lazy"></li>
<li><p>有了这些预测结果，即可计算得到每块椎骨的landmark角点坐标</p>
</li>
</ul>
</li>
</ul>
<h2 id="贪吃蛇"><a href="#贪吃蛇" class="headerlink" title="贪吃蛇"></a>贪吃蛇</h2><h1 id="机试"><a href="#机试" class="headerlink" title="机试"></a>机试</h1><ul>
<li><p>C++中的文件输入输出：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/lfri/p/10163062.html"><code>freopen</code>将输入输出重定向</a></p>
<p>此后原本用于标准输入输出的<code>cin/scanf</code>和<code>cout/printf</code>都会输出到文件中</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;a+b.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;a+b.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="comment">//以上是模板</span></span><br><span class="line">	<span class="keyword">int</span> a,b;</span><br><span class="line">	cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">	cout&lt;&lt;a+b;</span><br><span class="line">	<span class="comment">// 把标准输出stdout再重新定向回控制台，Windows中是&quot;CON&quot;，Linux中是&quot;/dev/console&quot;</span></span><br><span class="line">	<span class="comment">// freopen(&quot;CON&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line">	<span class="comment">// cout&lt;&lt;&quot;finish&quot;&lt;&lt;endl;</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li></li>
</ul>
<h1 id="英语"><a href="#英语" class="headerlink" title="英语"></a>英语</h1><img src="/2022/07/15/%E5%86%B2%EF%BC%81/image-20220908202701739.png" alt="image-20220908202701739" style="zoom:67%;" loading="lazy">

<ul>
<li><h3 id="Sorry-Can-you-pardon-it-again"><a href="#Sorry-Can-you-pardon-it-again" class="headerlink" title="Sorry,Can you pardon it again?"></a><strong>Sorry,Can you pardon it again?</strong></h3></li>
<li><p>一张图（英语常见问答）见文末</p>
</li>
<li><p><strong>Common expressions</strong></p>
<ul>
<li>Data center network</li>
<li>artificial intelligence</li>
<li>doctor master undergraduate senior</li>
<li>in advance</li>
<li>MST：minimum spanning tree</li>
<li>Greedy Algorithm</li>
<li>Edges and Points</li>
<li>Square of n / the second power of n</li>
<li>Expand your horizons</li>
<li>central idea</li>
<li>good environment</li>
<li>Complete graduation requirements</li>
<li>refuse</li>
<li>avoid</li>
<li>original intention</li>
<li>in order</li>
<li>Recursive</li>
<li>union-set</li>
<li>ancestor</li>
<li>amount</li>
<li>Directed acyclic graph(DAG)   acyclic(A-cyclic)</li>
<li>do A while doing B / and</li>
<li>repeat</li>
<li><u>Mark</u> v as the number of points in the graph</li>
<li>from small to large</li>
</ul>
</li>
<li><p><strong>talk about the union-set</strong></p>
<p>​    In the union-set, each node belongs to a set, and each set has a unique ancestor. We need a hash_ map to store the parent of each node, in which the key is node and the value is his parent.</p>
<p>​    Different with simple nodes, the ancestor of an ancestor node is itself. This is also the way to find ancestor nodes.</p>
<p>​    When we need to find the ancestor of a node, we find the parent of the node in the hash_map and perform this process recursively until the found parent is the node itself.</p>
<p>​    When we need to merge two sets, we only need to set the ancestor of one set as the parent of the other’s ancestor. This process is like merging two trees.</p>
</li>
<li><p><strong>talk about the Topological sort</strong></p>
<p>Directed acyclic graph(DAG) </p>
<p>in-degree</p>
<p>Delete them and update the in-degree of the other points.</p>
<p>The points we delete each time are in the same position in the ordered sequence.</p>
</li>
<li><p><strong>Talk about your hometown.</strong></p>
<p>​    I have the high privilege and sincere eagerness to present it to you, my beautiful hometown Sanmenxia.</p>
<p>​    It’s a delicate town located in the westernmost part of Henan Province, which is famous as the city of swans because numerous number of swans fly a long journey from Siberia over here every winter. We are quite confident that it is our agreeable natural environment that attracts these elegant creatures.</p>
<p>​    The reason why my hometown is called Sanmenxia is because Sanmenxia is based on the myth of Dayu cutting the mountain into three gorges, namely “Renmen”, “Shenmen” and “Guimen”, with his magic axe to lead the water of the Yellow River to the east. Hence the name of Sanmenxia.</p>
<p>​    Hangu pass is one of the historical sites here. It is said that Lao Tzu wrote the Tao Te Ching here.</p>
<p>​    Sanmenxia has profound historical culture and beautiful natural scenery. Welcome to my hometown and you bet I will treat you well.</p>
</li>
<li><p><strong>Introduce yourself in English.</strong></p>
<p>​    My name is Nan Haixin. I come from Huazhong University of Science and Technology. My major is Computer Science and Technology. My average grade is 90.74 (ninety point seven four), ranking about the top 3% (three percent) in my major.</p>
<p>​    I command a high level of proficiency in English. I got 473 (four hundred seventy-three)  in CET-6.</p>
<p>​    In addition, I participated in the China robot and artificial intelligence competition and won the national first prize. And I participated in the Interdisciplinary Contest In Modeling in 2022 and was awarded as Meritorious Winner.</p>
<p>​    What’s more, I was awarded the title of “Scholarship for National Encouragement” for two consecutive years. And I own a computer software copyright, in which I am the second copyright owner.</p>
<p>​    Fudan university is always my dream school and I hope I can be admitted to Nanjing University.</p>
</li>
<li><p><strong>Why do you choose our school?</strong></p>
<p>The first and most important point, Nanjing university has great advantage in Computer science and Technology, both in the field of artificial intelligence and systems. What’s more, I love the inclusive atmosphere of Nanjing University.</p>
<p>The school motto of Fudan University, free and useless, attracts me very much. And I love the inclusive atmosphere of Fudan University. Fudan university is located in Shanghai, and I love this city, and I think it is the most charming city in China and it has many opportunities there.</p>
</li>
<li><p><strong>Your strength and weakness?</strong></p>
<p>I am very organized in my work. For example, I am used to listing the learning plan of the day in my notebook every day. At the end of the day, I will review what I did that day and do some self reflection and daily summary.</p>
<p>When I am busy, I will become impatient with others and put my own things first. This will cause me to often ignore the feelings of others when I am busy. Now, although I am busy, I will actively respond to others and explain to others that I am busy in exchange for others’ understanding.</p>
</li>
<li><p><strong>What’s your plan after graduation?</strong></p>
<p>It is hard to say, I am more inclined to work, and of course I also have plans to further study.</p>
</li>
<li><p><strong>The reason for further studying?</strong></p>
<p>I realize what I have learned during the past years is not enough for the future, it is necessary to catch any opportunity for self-development.</p>
</li>
<li><p><strong>What’s your favorite course and why?</strong></p>
<p>​    There is no doubt that my favorite course is Computer Network. In the process of learning this course, I learned a lot of Internet protocols and have a deeper understanding of the Internet we use every day. It is these protocols that have formed the stable and reliable internet.</p>
<p>​    And when I finished my computer network experiment, and the web page I made could be accessed by a browser under the same local area network, I was very satisfied. </p>
</li>
<li><p><input disabled type="checkbox">  机器学习</p>
</li>
<li><p><input checked disabled type="checkbox">  数据库</p>
</li>
<li><p><input checked disabled type="checkbox">  计网</p>
</li>
<li><p><input disabled type="checkbox">  编译原理</p>
</li>
<li><p><input checked disabled type="checkbox">  概率论</p>
</li>
<li><p><input disabled type="checkbox">  线性代数、离散数学</p>
</li>
<li><p><input checked disabled type="checkbox">  组原</p>
</li>
<li><p><input checked disabled type="checkbox">  数据结构</p>
</li>
<li><p><input checked disabled type="checkbox">  操作系统</p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qian2213762498/article/details/80480888">面试知识点</a></p>
<ul>
<li><h4 id="主要问概念题"><a href="#主要问概念题" class="headerlink" title="主要问概念题"></a><strong>主要问概念题</strong></h4></li>
</ul>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><blockquote>
<p>Q：有一个循环队列Q，里面的编号是0到n-1，头尾指针分别是f，p，现在求Q中元素的个数？</p>
<p>A：<code>(p-f+n)%n</code></p>
<hr>
<p>Q：如何区分循环队列是队空还是队满？<br>A：如上，两种解决方式。牺牲一个单元则<code>(Q.rear+1)%MaxSize == Q.front</code>为队满，<code>Q.rear == Q.front</code>为队空；增设表示元素个数的数据成员则<code>Q.rear == Q.front</code>且<code>Q.size == 0</code>为队空，<code>Q.rear == Q.front</code>且<code>Q.size == MaxSize</code>为队满</p>
<hr>
<p>Q：==<a target="_blank" rel="noopener" href="https://www.cnblogs.com/lwtyyds/p/15569621.html">堆、大顶堆、小顶堆的实现及应用</a>==</p>
<p>A：堆是具有下列性质的<strong>完全二叉树</strong>：每个结点的值都大于或等于其左右孩子结点的值，称为大根堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小根堆。</p>
<p>耗费O(n)的复杂度建堆之后可以用O(logn)的复杂度<strong>维护一次堆</strong></p>
<p>插入新的数只需要插在最后，再更新一次堆即可；</p>
<p>删去最小值or任意一个（第k个）数只需要将其与最后一个数交换，删去最后一个数，再更新第k个数即可</p>
<hr>
<p>Q：<a target="_blank" rel="noopener" href="https://blog.csdn.net/Real_Fool_/article/details/114359564">哈希表的概念、==构造方法？哈希冲突的解决办法？==</a></p>
<p>A：散列表是根据关键字而直接进行访问的数据结构。也就是说，散列表建立了<strong>关键字</strong>和<strong>存储地址</strong>之间的一种直接映射关系。</p>
<p>构造哈希函数：直接定址法、数字分析法、平方取中法、<strong>除留余数法</strong>、随机数法</p>
<p>解决哈希冲突：开放定址法、链地址法（拉链法）、公共溢出区法</p>
<hr>
<p><strong>Q：无向图or有向图判断是否有环</strong></p>
<p>A：拓扑排序、并查集、DFS（<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38943651/article/details/108396570">链接</a>）</p>
<p>无向图还可以通过“n个顶点，n-1条边”来确定</p>
<hr>
<p>==<a target="_blank" rel="noopener" href="https://blog.csdn.net/u014453898/article/details/112469113"><strong>BST→AVL→B树→B+树</strong></a>==</p>
<ul>
<li><p>BST：二叉排序树</p>
</li>
<li><p>ACL：平衡二叉排序树</p>
<p>能确保AVL的查找、添加、删除的时间复杂度都是O(logn)</p>
<p>AVL树上任意结点的左、右子树的高度差最大为1</p>
</li>
<li><p>B树：平衡多路查找树</p>
<p>B树的所有叶子结点都位于同一层</p>
<p>其多路的性质帮助降低树的高度，减少查找次数</p>
<p>【B树不会有重复索引，每个结点都包含索引值和data两部分】</p>
</li>
<li><p>B+树</p>
<p>【B+树内部有两种结点，一种是索引结点，一种是叶子结点；可以理解为只有叶子结点有data】</p>
<p>B+树的叶子结点都会被连成一条链表。叶子本身按索引值的大小从小到大进行排序。即这条链表是 从小到大的。多了条链表方便范围查找数据</p>
<p>【B+树 非叶子结点的索引值 最终一定会全部出现在 叶子结点中】</p>
</li>
</ul>
<hr>
<p><strong>几种排序</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20210321102547844.png" alt="在这里插入图片描述" loading="lazy"></p>
<hr>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Gundam103/article/details/126214284">优先队列的原理</a>：本质上还是基于堆的上浮下沉操作</p>
</blockquote>
<h3 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h3><ul>
<li><p>时间复杂度：</p>
<p>一个<strong>语句的频度</strong>是指该语句在算法中被重复执行的次数。算法中所有语句的频度之和记为T(n), 它是该算法问题规模 n 的函数，<u>时间复杂度主要分析T(n) 的数量级</u>。</p>
<p>算法中基本运算（最深层循环内的语句）的频度与T(n) 同数量级，因此通常采用**算法中基本运算的频度f(n)**来分析算法的时间复杂度。</p>
<p><strong>而O(n)中的大O表示上紧确界，用于描述$f(n)$的上界</strong></p>
<blockquote>
<p>O(n)的大O是什么意思？什么是时间复杂度? </p>
</blockquote>
</li>
<li><p>数据结构的三要素：<strong>逻辑结构</strong>、<strong>存储结构</strong>（物理结构）和<strong>数据的运算</strong></p>
<ul>
<li><p>逻辑结构：指的是<strong>数据元素</strong>之间<strong>逻辑关系</strong>，与数的存储结构无关，是独立于计算机的，以下是分类图。</p>
<blockquote>
<p>与存储结构之间的区别是，例如数组属于顺序存储，链表属于链式存储，但他们都属于线性结构</p>
</blockquote>
<img src="/2022/07/15/%E5%86%B2%EF%BC%81/image-20220830155745130.png" class title="image-20220830155745130" loading="lazy"></li>
<li><p>存储结构：</p>
<ul>
<li><p>顺序存储：把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中，元素之间的关系由存储单元的邻接关系来体现。</p>
<p>【优点】支持<u>随机存取</u></p>
<p>【缺点】使用连续空间导致产生较多的碎片；插入删除需要移动元素</p>
</li>
<li><p>链式存储：不要求逻辑相邻的元素物理位置也相邻，借助指针来表示逻辑关系</p>
<p>【优点】充分利用存储空间，无碎片现象；且插入删除不需要移动其他元素</p>
<p>【缺点】指针占用额外<strong>存储空间</strong>，且<u>只能顺序存取（无法随机存取）</u></p>
</li>
<li><p>索引存储：（与hash散列存储不同）要在索引表中查找索引项，进而得出地址，索引表一般存储（关键字，地址）</p>
<p>例如数据库中建立的索引</p>
<p>【优点】检索速度快</p>
<p>【缺点】使用索引表增加了额外的<strong>空间占用</strong>；增加和删除数据时也要修改索引表</p>
</li>
<li><p>散列存储：（又称hash存储）根据元素的关键字直接计算出该元素的存储地址</p>
<p>【优点】检索、增加和删除结点的操作都很快</p>
<p>【缺点】若散列函数不好，则可能出现元素存储单元的<strong>冲突</strong>，而解决冲突会增加时间和空间开销。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>递归与迭代：</p>
<p>在循环的次数较大的时候，迭代的效率明显高于递归。</p>
<p>递归调用需要维护<strong>活动记录</strong>，而迭代直接复用了存储，可以省略这些开销，所以体系结构若执行显式递归调用一般更慢。但这里一般也不会慢多少，主要还是<strong>存储空间</strong>有压力（调用栈溢出）。</p>
</li>
</ul>
<h3 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h3><ul>
<li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u013593035/article/details/45953605">头指针和头结点的区别：</a></p>
<blockquote>
<p>不太懂没有头结点的时候为什么头指针不能为空，那这个时候空链表的头指针不就是null吗</p>
<p>还是默认有头结点好了</p>
<p><img src="https://pica.zhimg.com/80/b259fa0961ec56550ceec43e6d5899fd_720w.jpg" alt="img" loading="lazy"></p>
</blockquote>
<ul>
<li><p>头指针</p>
<ul>
<li><p>头指针是指链表指向第一个结点的指针，<strong>若链表有头结点，则是指向头结点的指针</strong></p>
</li>
<li><p>头指针具有标识作用，所以头指针冠以链表的名字（指针变量的名字）</p>
</li>
<li><p><strong>无论链表是否为空，头指针均不为空</strong></p>
<p><code>ListNode dummy = new ListNode(0);</code>这句创建出来的**<code>dummy</code>就是头指针**，有头指针才有链表，所以“无论链表是否为空，头指针均不为空”</p>
<p>头指针是一个指针！并没有值域</p>
</li>
<li><p><strong>头指针是链表的必要元素</strong></p>
</li>
</ul>
</li>
<li><p>头结点</p>
<ul>
<li>头结点是为了操作的统一和方便而设立的，放在第一个元素的结点之前，其数据域一般无意义（但也可以用来存放链表的长度）</li>
<li><strong>有了头结点，对在第一元素结点前插入结点和删除第一结点起操作与其它结点的操作就统一了</strong></li>
<li>头结点不一定是链表的必要元素</li>
</ul>
</li>
</ul>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/51545092">链表和数组的插入删除时间复杂度都是o(n)，为什么教材网络上说链表效率高？</a></p>
</li>
</ul>
<h3 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h3><ul>
<li><p>共享栈：</p>
<img src="/2022/07/15/%E5%86%B2%EF%BC%81/image-20220830184519403.png" class title="image-20220830184519403" loading="lazy"></li>
<li><p>栈和队列都可以用定长数组模拟，而<u>循环队列</u>也是用定长数组模拟队列，<u>普通的模拟队列</u>没有循环的特性</p>
<ul>
<li><p>对于循环队列：判断队列空和满【队头指针指向第一个数；队尾指针指向最后一个数的下一个位置，即将要入队的位置】</p>
<img src="/2022/07/15/%E5%86%B2%EF%BC%81/image-20220830185251321.png" class title="image-20220830185251321" loading="lazy"></li>
</ul>
</li>
<li><p>【栈的用途】括号匹配、计算后缀表达式、递归</p>
<p>【队列的用途】树的层序遍历、任务处理的等待队列</p>
</li>
</ul>
<h3 id="串"><a href="#串" class="headerlink" title="串"></a>串</h3><ul>
<li><p>子串的定位称为模式匹配</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_52622200/article/details/110563434">KMP</a>：匹配过程的时间复杂度为O (n)，计算next数组的时间复杂度为O (m)，共O(m+n)</p>
<p>主串—子串（模式串）</p>
<ul>
<li><p>在KMP算法中，（记i为主串中的下标，j为子串中的下标）<strong>i不会回溯，只用在主串中遍历一遍</strong>。</p>
</li>
<li><p>【KMP流程】遇到不匹配的情况，i保持不变，j移动到<code>next[j]</code>处，继续匹配。</p>
</li>
<li><p>【KMP本质】所以KMP是空间换时间的方法，需要预处理的只有模式串（子串），计算子串的<code>next</code>数组。</p>
</li>
<li><p>【<code>next[j]</code>含义】<code>next[j]</code>存的是子串【从j往前数的后缀（<strong>不包含j</strong>）】与【从0往后数的前缀】最大重合的长度</p>
</li>
<li><p>【特殊处理】<code>next[0] = -1</code>，表示上来第一个就不一样，这时只能<code>i++</code></p>
<p><img src="https://img-blog.csdnimg.cn/20201203201211489.png" alt="img" loading="lazy"></p>
</li>
<li><p>【<code>next数组</code>求法】：</p>
<p><strong>一共j和k两个下标</strong></p>
<ul>
<li><p>当<code>P[k] == P[j]</code>时， 有<code>next[j+1] == next[j] + 1</code></p>
<p><img src="https://img-blog.csdnimg.cn/20201203201234972.png" alt="在这里插入图片描述" loading="lazy"></p>
</li>
<li><p>当<code>P[k] != P[j]</code>时，有<code>k = next[k]</code></p>
<p><img src="https://img-blog.csdnimg.cn/20201203201303948.png" alt="在这里插入图片描述" loading="lazy"></p>
<blockquote>
<p>上边的例子，我们已经不可能找到[ A，B，A，B ]这个最长的后缀串了，但我们还是可能找到[ A，B ]、[ B ]这样的前缀串的。所以这个过程像不像在定位[ A，B，A，C ]这个串，当C和主串不一样了（也就是k位置不一样了），那当然是把指针移动到next[k]啦。</p>
</blockquote>
</li>
</ul>
<p>核心代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span> (j &lt; p.length - <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">-1</span> || p[j] == p[k]) &#123;</span><br><span class="line">		next[++j] = ++k;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		k = next[k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="树与二叉树"><a href="#树与二叉树" class="headerlink" title="树与二叉树"></a>树与二叉树</h3><p><a href="https://wan-nan.github.io/2022/08/27/662.%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E5%A4%A7%E5%AE%BD%E5%BA%A6%EF%BC%88%E4%BA%8C%E5%8F%89%E6%A0%91%E6%80%BB%E7%BB%93%EF%BC%89/">662.二叉树最大宽度（二叉树总结）</a></p>
<h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS80ZjIxOGE0Zi1iNGYzLTQwZTEtOWM0Mi0yYTIwNjMyMGY5YmEucG5n?x-oss-process=image/format,png" alt="img" loading="lazy"></p>
<p>见我的另一篇<a href="https://wan-nan.github.io/2022/08/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE-%E6%80%BB%E7%BB%93/">数据结构-图-总结</a></p>
<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Real_Fool_/article/details/114359564">参考文章</a></p>
<p>这章没看，摆了</p>
<p><u>删除二叉排序树中某个有两个孩子的结点时，需要查找中序遍历中该元素的直接后继来代替</u></p>
<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p><img src="https://img-blog.csdnimg.cn/20210321102547844.png" alt="在这里插入图片描述" loading="lazy"></p>
<p>几种排序算法<a target="_blank" rel="noopener" href="https://blog.csdn.net/Real_Fool_/article/details/114692744">这里</a>都有介绍</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/Histranger_/article/details/108811779">O(n)的时间复杂度求无序序列中位数</a>【使用快排中的Partition()操作】</li>
</ul>
<h2 id="概率论"><a href="#概率论" class="headerlink" title="概率论"></a>概率论</h2><ul>
<li><p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43595277/article/details/120580803">保研面试/考研复试概率论与数理统计问题整理</a></p>
</li>
<li><p>古典概型：优先等可能</p>
<p>几何概型：无线等可能（如正方形中圆形的概率）</p>
</li>
<li><p>大数定律：</p>
<p>当样本数据无限大时，样本均值趋于总体均值（期望值）。</p>
<p>When the sample data is infinite, the sample mean tends to the overall mean.</p>
<p>大数定律告诉我们能用频率近似代替概率；能用样本均值近似代替总体均值。</p>
</li>
<li><p>中心极限定理：样本数量无穷大的时候，<strong>样本均值的分布</strong>呈现<strong>正态分布</strong></p>
<blockquote>
<p>中心极限定理指的是给定一个任意分布的总体。我每次从这些总体中随机抽取 n 个抽样，一共抽 m 次。 然后把这 m 组抽样分别求出平均值。 这些<strong>平均值的分布接近正态分布</strong>。</p>
</blockquote>
<ul>
<li><strong>总体本身的分布不要求正态分布</strong><br>对于人的体重等例子，其总体原本就满足正态分布。但如果我们的例子是掷一个骰子（离散型随机变量），最后每组的平均值也会组成一个正态分布。（神奇！）</li>
</ul>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/128809461">正态分布</a>：</p>
<p>正态分布描述的是一种【连续型随机变量】的分布。对于这种变量，我们不关注点概率，只关注区间概率</p>
<p>正态分布的曲线是其概率密度函数，与横轴的面积为该区间的概率</p>
<ul>
<li><p>两个<strong>相互独立</strong>的正态分布之和仍然符合正态分布</p>
<img src="/2022/07/15/%E5%86%B2%EF%BC%81/image-20220904185842790.png" class title="image-20220904185842790" loading="lazy"></li>
<li><p>两个<strong>相互独立</strong>的正态分布的乘积等价于正态分布的概率密度函数乘一个常数，即积分过后得到一个不等于1的常数</p>
<img src="/2022/07/15/%E5%86%B2%EF%BC%81/image-20220904190411479.png" class title="image-20220904190411479" loading="lazy"></li>
</ul>
</li>
<li><p>全概率公式和贝叶斯公式</p>
<p><strong>全概率公式</strong>：</p>
<p><img src="https://img-blog.csdnimg.cn/eb2c7ddfd4d54e3faa1edc4f16d01267.png" alt="在这里插入图片描述" loading="lazy"></p>
<img src="/2022/07/15/%E5%86%B2%EF%BC%81/image-20220904164155297.png" alt="image-20220904164155297" style="zoom:67%;" loading="lazy">

<p><strong>贝叶斯公式</strong>：（<strong>本质是</strong>条件概率公式，<strong>但实际上还是两个东西</strong>）</p>
<p>其作用是：基于已知的【先验概率和条件概率】<strong>求后验概率</strong></p>
<img src="/2022/07/15/%E5%86%B2%EF%BC%81/image-20220904164310623.png" class title="image-20220904164310623" loading="lazy"></li>
<li><p>理解先验概率和后验概率：</p>
<p><strong>先验概率</strong>：事情未发生，只根据以往数据统计，分析事情发生的可能性，即先验概率。</p>
<p><strong>后验概率</strong>：事情已发生，已有结果，求引起这事发生的因素的可能性，由果求因，即后验概率。</p>
<ul>
<li><p>感冒、中风、脑溢血导致头痛的概率为先验概率</p>
<p>现在有一个病人头痛，其感冒的概率则为后验概率</p>
</li>
<li><p>全概率公式由因求果，其中的概率即为先验概率</p>
<p>后验概率的计算需要借助先验概率，使用贝叶斯公式，由果推因</p>
</li>
</ul>
</li>
<li><p>理解<strong>互斥和独立</strong></p>
<img src="/2022/07/15/%E5%86%B2%EF%BC%81/image-20220904164911764.png" class title="image-20220904164911764" loading="lazy"></li>
<li><p><strong>不相关</strong>和<strong>独立</strong>的区别：</p>
<p>不相关说的是：两个变量的相关系数为0，两个变量之间没有<strong>线性关系</strong></p>
<p>独立说的是：P(AB)=P(A)×P(B)，事件 A 发生的概率不影响事件 B 发生的概率</p>
<p>所以有：</p>
<ul>
<li>独立一定不相关</li>
<li>不相关不一定独立（可能不是线性关系，但有其他关系，导致P(AB)≠P(A)×P(B)）</li>
</ul>
</li>
<li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/baishuiniyaonulia/article/details/82827704">离散型随机变量和连续型随机变量及其常见分布</a></p>
<p><img src="https://pic4.zhimg.com/80/v2-2f535e26b4a54ca73a3e7c136b004f8f_720w.jpg" alt="img" loading="lazy"></p>
</li>
<li><p>期望和方差：$D(X)=E((X−E(X))^2)=E(X^2)−E^2(X) $（期望 = 平方的期望 - 期望的平方）</p>
</li>
<li><p>协方差—相关系数</p>
<p>协方差or相关系数=0  =&gt; 不线性相关（不能说明独立or无关）</p>
<img src="/2022/07/15/%E5%86%B2%EF%BC%81/image-20220904192625535.png" class title="image-20220904192625535" loading="lazy"></li>
<li><p><strong>假设检验</strong>的例子：</p>
<img src="/2022/07/15/%E5%86%B2%EF%BC%81/image-20220904200407027.png" class title="image-20220904200407027" loading="lazy">

<img src="https://img-blog.csdnimg.cn/img_convert/22ad737da296f679688ada95924a6b01.png" alt="BkTG6J.jpg" style="zoom:50%;" loading="lazy">

<blockquote>
<p>假设：我的硬币公平，则按照这个假设计算出“10次掷出9次正面”的概率为0.01，小于显著水平0.05，可以认定为不可能事件，所以假设不正确</p>
</blockquote>
</li>
<li><p>概率（probability）和似然（likelihood）的区别</p>
<img src="/2022/07/15/%E5%86%B2%EF%BC%81/image-20220904200802135.png" class title="image-20220904200802135" loading="lazy"></li>
<li><p>最大似然估计：</p>
<p><strong>利用已知的样本结果信息，反推最具有可能（最大概率）导致这些样本结果出现的模型参数值</strong></p>
</li>
<li><p>解题步骤</p>
<ul>
<li>写出总体分布概率密度函数</li>
<li>写出似然函数</li>
<li>求似然函数的最大值（取对数后，求导，令其等于0）求解估计的参数</li>
</ul>
</li>
<li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/LucasXu01/article/details/107637235">马尔科夫链</a></p>
<blockquote>
<p>马尔可夫链就是这样一个任性的过程，<strong>它将来的状态分布只取决于现在，跟过去无关！这就是马尔科夫过程(Markov Processes)的体现，</strong></p>
</blockquote>
</li>
<li><p>问题集锦：</p>
<p>夫妇生孩：</p>
<img src="/2022/07/15/%E5%86%B2%EF%BC%81/image-20220904201409888.png" class title="image-20220904201409888" loading="lazy">

<p>大数定律玩骰子：</p>
<img src="/2022/07/15/%E5%86%B2%EF%BC%81/image-20220904201506836.png" class title="image-20220904201506836" loading="lazy">

<p>罐子抽球“最大似然”：</p>
<img src="/2022/07/15/%E5%86%B2%EF%BC%81/image-20220904201651850.png" class title="image-20220904201651850" loading="lazy">

<p>线性规划：</p>
<img src="/2022/07/15/%E5%86%B2%EF%BC%81/image-20220904201742044.png" class title="image-20220904201742044" loading="lazy">

<p>抛硬币吃苹果：</p>
<img src="/2022/07/15/%E5%86%B2%EF%BC%81/image-20220904201851430.png" class title="image-20220904201851430" loading="lazy">

<p>均分扑克牌后大小王在一起：（大小王被分配这两个事件并不独立，所以要列出所有可能性进行计算）</p>
<img src="/2022/07/15/%E5%86%B2%EF%BC%81/image-20220904202110648.png" class title="image-20220904202110648" loading="lazy"></li>
</ul>
<h2 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h2><h2 id="组原"><a href="#组原" class="headerlink" title="组原"></a>组原</h2><p>看的这个：<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_52571748/article/details/119530739">计算机组成原理保研面试题整理（自用）</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_39328436/article/details/114849681">【组成原理】- 经典面试题吐血整理</a></p>
<ul>
<li><p><strong>总线</strong>：总线是连接各个部件的信息传输线，使各个部件共享的传输介质</p>
<p>总线分为<u>内部总线、系统总线和通信总线</u>。内部总线指芯片内部连接各元件的总线。系统总线指连接计算机各部件的总线。外部总线则是计算机系统之间或计算机系统与其他系统之间的通信。</p>
<p>其中，<strong>系统总线</strong>又分为三类，数据总线，地址总线和控制总线</p>
<ul>
<li><p>引入总线的目的：</p>
<p>在冯诺依曼结构中，各个部件之间均有单独连线，不仅线多，而且导致扩展I/O设备很不容易。即扩展一个I/O设备，需要连接很多线。 因此，引入了总线连接方式，将多个设备连接在同一组总线上，构成设备之间的公共传输通道。</p>
</li>
<li><p>总线的两大特征：</p>
<p>1）<strong>共享</strong>：多个部件连接在同一组总线上，各个部件之间都通过该总线进行数据交换。</p>
<p>2）<strong>分时</strong>：同一时刻，总线上只能传输一个部件发送的信息；</p>
</li>
</ul>
</li>
<li><p>数据校验：增加冗余码（校验位）</p>
<ul>
<li>奇偶校验（不具备纠错能力）</li>
<li>CRC循环冗余校验</li>
<li>海明校验</li>
</ul>
</li>
<li><p>存储系统层次结构：</p>
<p>缓存-主存：缓解<strong>CPU和主存速度不匹配</strong>的问题，由<strong>硬件</strong>来完成</p>
<p>主存-辅存：解决<strong>主存容量不够</strong>的问题，由<strong>操作系统和硬件</strong>共同完成</p>
</li>
<li><p>存储方式：大端-小端（<strong>回想学汇编时栈的存储，即为小端方式</strong>）</p>
<ul>
<li>大端：字的低位存在内存的高地址中，而字的高位存在内存的低地址中；</li>
<li>小端：字的低位存在内存的低地址中，而字的高位存在内存的高地址中；</li>
</ul>
</li>
<li><p>存储器的扩展通常有位扩展和字扩展</p>
<p>1）<strong>位扩展</strong>：增加存储器的字长，例如两个1K * 4位的存储芯片构成1个1K*8位的存储器； </p>
<p>2）<strong>字扩展</strong>：增加存储器的字数，例如两个1K * 8位的存储芯片构成1个2K * 8位的存储器；</p>
</li>
<li><p>在CPU和内存之间引入cache的原因</p>
<p>1）避免CPU空等<strong>I/O访存</strong>； </p>
<p>2）缓解CPU和<strong>主存速度</strong>不匹配的问题。</p>
</li>
<li><p> Cache写操作有哪两种方式</p>
</li>
</ul>
<p>  1）<strong>写直达法</strong>：写操作既写入Cache又写入主存； </p>
<p>  2）<strong>写回法</strong>：只把数据写入Cache而不写入主存，直到Cache的该数据块将被驱逐出缓存时才写入主存。</p>
<ul>
<li><p><strong>Cache与主存的地址映射方式</strong>：</p>
<ul>
<li><p>直接相联</p>
</li>
<li><p>全相联</p>
</li>
<li><p>组相联：主存和Cache都<strong>分组</strong>，主存中一个<strong>组内的块数</strong>与Cache中的<strong>分组数</strong>相同，组间采用直接映射，组内采用全相联映射。</p>
</li>
</ul>
</li>
<li><p><strong>Cache替换算法</strong>：</p>
<p>先进先出法-FIFO(First in First out)</p>
<p>最不经常使用法—LFU (Least Frequently Used)</p>
<p>近期最少使用法—LRU(Least recently used )</p>
</li>
<li><p><strong>TLB</strong>：（Translation Lookaside Buffer）</p>
<ul>
<li><p>什么是TLB：</p>
<p>简单地说，TLB就是页表的Cache，其中存储了当前最可能被访问到的页表项，其内容是部分页表项的一个副本。只有在TLB无法完成地址翻译任务时，才会到内存中查询页表，这样就减少了页表查询导致的处理器性能下降。</p>
</li>
<li><p>为什么需要TLB</p>
<ul>
<li><p>虚实地址转换时需要访问<strong>主存中的页表</strong>，访问主存是很耗时的，因为cache的高速特性得不到发挥</p>
</li>
<li><p>缺页-找到的页不在主存中-缺页异常处理程序-将存放在辅存中的调入到主存中</p>
<p>调入后，要重新走一边查找的流程，重新查找一次页号</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>中断服务程序的基本流程</strong>：</p>
<p>1）保护现场 2）中断服务 3）恢复现场 4）中断返回</p>
</li>
<li><p><strong>DMA</strong>：</p>
<p>DMA，全称Direct Memory Access，即直接存储器访问，指<strong>外部设备不通过CPU而直接与系统内存交换数据</strong>的接口技术。</p>
<blockquote>
<p>​        但是采用中断传送有它的缺点，对于一个<strong>高速I/O</strong>设备，以及<strong>批量交换数据</strong>的情况，只能采用DMA方式，才能解决效率和速度问题。DMA在外设与内存间直接进行数据交换，而不通过CPU，这样数据传送的速度就取决于存储器和外设的工作速度。<br>　　通常系统的总线是由CPU管理的。在DMA方式时，就希望CPU把这些总线让出来，即CPU连到这些总线上的线处于第三态–高阻状态，而由DMA控制器接管，控制传送的字节数，判断DMA是否结束，以及发出DMA结束信号。</p>
</blockquote>
<ul>
<li><p>DMA与中断对比：</p>
<img src="https://img-blog.csdnimg.cn/20210205152509698.png" alt="在这里插入图片描述" style="zoom: 33%;" loading="lazy"></li>
</ul>
</li>
<li><p><strong>程序中断和调用子程序的区别</strong>：</p>
<blockquote>
<p>两者的根本区别主要表现在<strong>服务时间</strong>和<strong>服务对象</strong>上不一样。</p>
<p>调用子程序过程发生的时间是已知的和固定的。而中断过程发生的时间一般是随机的。也可以说，调用子程序是程序设计者事先安排的，而执行中断服务程序是由系统工作环境随机决定的。</p>
<p>子程序完全为主程序服务，两者属于主从关系。而中断服务程序与主程序二者一般是无关的，两者是平行关系。</p>
<p>主程序调用子程序的过程完全属于软件处理过程，不需要专门的硬件电路；而中断处理系统是一个软／硬件结合的系统，需要专门的硬件电路才能完成中断处理的过程。</p>
<p>子程序嵌套可实现若干级，嵌套的最多级数受计算机内存开辟的堆栈大小限制；而中断嵌套级数主要由中断优先级来决定，一般优先级数不会很大。</p>
</blockquote>
</li>
<li><p><strong>五级流水CPU的各阶段</strong>：</p>
<p>取指（IF）</p>
<p>译码（ID，同时取出操作数）</p>
<p>执行（EX）</p>
<p>访存（访问存储器，MEM）</p>
<p> 写回（数据写回到目标寄存器，WB）</p>
</li>
<li><p><strong>流水线的冲突相关</strong>可以看<a href="https://wan-nan.github.io/2022/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0/">系统结构的复习笔记</a></p>
</li>
<li><p><strong>影响流水线性能的因素</strong></p>
<ul>
<li><p><strong>结构相关</strong>是当多条指令同一时刻争用同一资源形成冲突</p>
<p>解决方案：（1）暂停一个时钟周期（2）<u>单独设置数据存储器和指令存储器</u></p>
</li>
<li><p><strong>数据相关</strong>是指令在流水线中重叠执行时,当后继指令需要用到前面指令的执行结果时发生的冲突</p>
<p>解决方案：（1）暂停一个时钟周期（2）数据旁路：把前一条指令的ALU计算结果直接输入到下一条指令</p>
</li>
<li><p><strong>控制相关</strong>是当流水线遇到分支指令和其他改变PC值的指令时引起的.</p>
<p>解决方案：</p>
<p>(1)延迟转移技术。将转移指令与其前面的与转移指令无关的一条或几条指令对换位置，让成功转移总是在紧跟的指令被执行之后发生，从而使预取的指令不作废。</p>
<p>(2)转移预测技术。（<strong>动态分支预测</strong>）</p>
</li>
</ul>
</li>
</ul>
<h2 id="计网"><a href="#计网" class="headerlink" title="计网"></a>计网</h2><ul>
<li><p>IP地址相关：（也可以帮助理解Frp的原理）</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/tunian/p/9632893.html">IP地址分类</a></p>
<ul>
<li>本机ipconfig查到的IP地址：（这个实际上是内网IP）  <img src="/2022/07/15/%E5%86%B2%EF%BC%81/image-20220718205628921.png" class title="image-20220718205628921" loading="lazy"></li>
<li>百度“IP地址”查到的地址：（这个是公网IP）<pre><code>&lt;img src=&quot;冲！/image-20220718205727962.png&quot; alt=&quot;image-20220718205727962&quot; style=&quot;zoom:67%;&quot; /&gt;
</code></pre>
</li>
</ul>
</li>
<li><p><strong>网络边缘</strong>、<strong>网络核心</strong>和<strong>接入网络</strong></p>
<p> 网络边缘是指<code>主机or网络应用</code></p>
<p> 网络核心是指<code>互联的路由器or分组的转发设备</code></p>
<p> 接入网络：有线或无线通信链路</p>
</li>
<li><p>路由器的关键功能：路由+转发</p>
</li>
<li><p><strong>报文交换-分组交换-电路交换</strong></p>
<ul>
<li><p>报文交换不存在多路复用，是将数据整个进行传输</p>
<p>比较落后</p>
</li>
<li><p>分组交换是在报文交换的基础上对数据进行分组传输，为<strong>统计多路复用</strong>（<u>按需共享链路</u>）</p>
<p>适合突发数据传输（不需要花时间像电路交换那样建立链路）</p>
<p><strong>分组交换的报文交付时间公式</strong>：<u>一个分组走h-1跳+所有报文走1跳</u></p>
</li>
<li><p>电路交换：建立连接，通信，释放连接</p>
<p>例如电话网络</p>
<blockquote>
<p>Q:判断：电路交换网络中，每条电路独占其经过的物理链路。</p>
<p>A:<strong>×</strong></p>
</blockquote>
<blockquote>
<p>Q:判断：电路交换更适合<strong>实时数据流传输</strong>。</p>
<p>A:<strong>√</strong></p>
</blockquote>
<p>电路交换中也有几种多路复用技术：</p>
<ul>
<li>频分多路复用（电视）</li>
<li>时分多路复用</li>
<li>波分多路复用</li>
<li>码分多路复用</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>速率</strong>-<strong>带宽</strong>-<strong>延迟</strong>-<strong>时延带宽积</strong></p>
<ul>
<li><p>一般讨论的都是<strong>传输延迟</strong>，即关于数据大小(<strong>bits/B</strong>)和传输速率/带宽(<strong>bps</strong>)的延迟</p>
<p>高速网络链路提高的也是数据的传输速率</p>
</li>
<li><p>而传播速率的单位是(<strong>m/s</strong>)</p>
</li>
<li><p>时延带宽积（单位bits）：**<u>传播</u>*<em>时延</em>带宽</p>
<p>也成为<u>以比特为单位的链路长度</u></p>
</li>
</ul>
</li>
<li><p>五层参考模型</p>
 <img src="https://img-blog.csdnimg.cn/d6d79380aeee4d95935047201400438e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAd2FuX25hbg==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="5层参考模型" style="zoom: 50%;" loading="lazy">

<ul>
<li><p><strong><a target="_blank" rel="noopener" href="https://blog.csdn.net/hanzhen7541/article/details/79071615">传输层作用</a></strong></p>
</li>
<li><p><strong><a target="_blank" rel="noopener" href="https://blog.csdn.net/hanzhen7541/article/details/79030748">网络层作用</a></strong></p>
</li>
<li><p>数据在各层之间的传递过程（数据链路层封装数据报构成数据帧，加<strong>首部和尾部</strong>）</p>
</li>
</ul>
 <img src="https://img-blog.csdn.net/20160126223713317" alt="img" style="zoom: 67%;" loading="lazy"></li>
</ul>
<h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>HTTP、SMTP、DNS</p>
<ul>
<li><p><strong>套接字socket</strong></p>
<p>Socket是<strong>应用层</strong>与<strong>TCP/IP协议族（传输层）通信</strong>的<strong>中间软件抽象层</strong>，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。（协助运输层复用/分解的实现）</p>
<ul>
<li><p>如何编写socket套接字</p>
<img src="/2022/07/15/%E5%86%B2%EF%BC%81/image-20220809171532514.png" alt="image-20220809171532514" style="zoom:80%;" loading="lazy"></li>
<li><p>UDP套接字由二元组：（目的ip，目的端口号）来<strong>标识</strong>，但<strong>UDP报文段仍包含了源ip和源端口号，可以在接收端获取</strong></p>
<p>TCP套接字由四元组：（源ip，源端口号，目的ip，目的端口号）来<strong>标识</strong></p>
</li>
</ul>
</li>
<li><p><strong>寻址进程</strong></p>
<p>端口号是一个<strong>16bits</strong>的数，范围是0 ~ 65535；0 ~ 1023之间的端口号称为<strong>周知端口号</strong></p>
<img src="https://img-blog.csdnimg.cn/565cb4037b334682bee06def7c557e0e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAd2FuX25hbg==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="寻址进程" style="zoom:67%;" loading="lazy"></li>
<li><p><strong>HTTP</strong></p>
<img src="https://img-blog.csdnimg.cn/3ece21be6086485a8d01bf92c492d956.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAd2FuX25hbg==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="HTTP" style="zoom: 50%;" loading="lazy">

<p>TCP是有状态协议</p>
<ul>
<li><p>HTTP是<a target="_blank" rel="noopener" href="https://baijiahao.baidu.com/s?id=1729612459413708578">无状态协议</a></p>
<blockquote>
<p><strong>即HTTP的每个请求都是完全独立的，每个请求包含了处理这个请求所需的完整的数据，发送请求不涉及到状态变更。即使在 HTTP/1.1 上，同一个连接允许传输多个 HTTP 请求的情况下，如果第一个请求出错了，后面的请求一般也能够继续处理</strong></p>
</blockquote>
</li>
<li><p><u>非持久性连接 -&gt; 无流水的持久性连接 -&gt; 带有流水机制的持久性连接</u></p>
<p><a href="HTTP/1.1%E7%9A%84%E6%8C%81%E4%B9%85%E6%80%A7%E8%BF%9E%E6%8E%A5%E5%92%8C%E6%B5%81%E6%B0%B4%E4%BC%A0%E8%BE%93">HTTP/1.1的持久性连接和流水传输</a></p>
<p>（区分持久性连接和无状态协议）</p>
</li>
<li><p>HTTP报文是ASCII编码，人直接可读</p>
</li>
</ul>
</li>
<li><p><strong>SMTP</strong></p>
<ul>
<li><p>SMTP是有状态协议</p>
<blockquote>
<p>常见的许多七层协议实际上是有状态的，例如 <strong>SMTP 协议</strong>，它的第一条消息必须是 HELO，用来握手，在 HELO 发送之前其他任何命令都是不能发送的；接下来一般要进行 AUTH 阶段，用来验证用户名和密码；接下来可以发送邮件数据；最后，通过 QUIT 命令退出。<strong>可以看到，在整个传输层上，通信的双方是必须要时刻记住当前连接的状态的，因为不同的状态下能接受的命令是不同的；另外，之前的命令传输的某些数据也必须要记住，可能会对后面的命令产生影响。这种就叫做有状态的协议。</strong></p>
</blockquote>
</li>
<li><p>使用TCP进行email信息的可靠传输</p>
</li>
<li><p>端口25</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_46045632/article/details/122674052">SMTP说明（与HTTP的对比）</a></p>
<ul>
<li>两者都是持久性连接</li>
<li>HTTP是拉式，SMTP是推式</li>
<li>SMTP要求每个报文使用7比特ASCII码格式（即七位的ASCII 码，ASCII码的取值范围是<strong>0~127</strong>）</li>
<li>对于既包含文本又包含图形（也可能是其他媒体类型）的文档，HTTP把每个对象封装在独立的响应消息中，而SMTP则把所有消息对象放在一个报文之中</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>POP3</strong>协议是<strong>无状态</strong>的</p>
<p>POP是负责<strong>邮件程序和邮件服务器收信</strong>的通讯协定，SMTP则是负责<strong>邮件服务器与邮件服务器之间的寄信</strong>的通讯协定</p>
<p>163、QQ Mail等邮箱都是基于HTTP协议的</p>
</li>
<li><p><strong>DNS</strong></p>
<p><strong>Domain Name System</strong> 域名解析系统：<strong>域名→IP地址</strong></p>
<blockquote>
<p><strong>先浏览器缓存 查询 是否之前已经解析过一次</strong></p>
<p><strong>系统缓存</strong></p>
<p><strong>路由器缓存</strong></p>
<p><strong>本地域名服务器</strong></p>
<p><strong>根域名服务器</strong></p>
<p><strong>顶级域名服务器</strong></p>
<p><strong>极限域名服务器</strong></p>
</blockquote>
</li>
</ul>
<h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><blockquote>
<p><strong>主要是TCP和UDP，这部分看书学习</strong></p>
</blockquote>
<ul>
<li><p><strong><a target="_blank" rel="noopener" href="https://blog.csdn.net/hanzhen7541/article/details/79071615">传输层作用</a></strong></p>
<p>复用和分解：区分不同进程的数据并且加以区分处理</p>
<p>可靠数据传输：（为了弥补网络层的不足）流量控制、拥塞控制、差错检测等等</p>
</li>
<li><p>运输层协议只工作在端系统中，在端系统中，运输层协议将来自应用层的<strong>报文</strong>移动到<strong>网络边缘（即网络层）</strong>，但对这些报文在网络核心如何移动并不做任何规定</p>
</li>
<li><p>UDP和TCP的服务模型：</p>
<ul>
<li><p>传输层提供的两种<strong>最低限度</strong>的服务（也即<strong>UDP</strong>提供的服务）：<strong>进程到进程的数据交付（复用和分解）</strong>和少量的<strong>差错检查</strong></p>
<p>但UDP和IP服务一样，都<strong>不可靠</strong></p>
</li>
<li><p>TCP提供了附加服务：</p>
<p>【**<u>可靠</u>数据传输**】——通过使用流量控制、序号、确认和定时器，TCP确保将数据正确地、按序地从发送进程交付给接收进程，从而将端系统间不可靠的IP服务转换成了进程间的可靠数据传输服务</p>
<p>【<strong>拥塞控制</strong>】——TCP力求为每一个通过一条拥塞网络链路的连接平等地共享网络链路带宽，这可以通过<strong>调节</strong>TCP连接的发送端发送进网络的<strong>流量速率</strong>来做到（“一种带来通用好处的服务”）。而UDP的流量不可调节，使用UDP的应用程序可以根据其需要以任何速率发送数据</p>
</li>
</ul>
</li>
<li><p>UDP相对于TCP的优势：</p>
<ul>
<li>【可靠交付耗时】：TCP拥塞控制等确保<strong>可靠交付</strong>的操作会导致<strong>耗时</strong>增加，于是一些能容忍部分数据丢失的<strong>实时应用</strong>会使用UDP</li>
<li>【建立连接耗时】：TCP会引入<strong>建立连接的时延</strong>，DNS等服务为了加快速度选择使用TCP</li>
<li>【连接状态的维护】：TCP需要在端系统中维护连接状态，包括接收缓存、发送缓存和拥塞控制等的一些参数，选择运行在UDP上能比运行在TCP上<strong>支持更多活跃用户</strong></li>
<li>【报文段开销】：TCP首部20字节，UDP首部8字节</li>
</ul>
</li>
<li><p>可靠数据传输协议发展：rdt-&gt;（引入流水线）GBN滑动窗口协议-&gt;SR选择重传协议-&gt;TCP</p>
<p><strong>GBN和SR</strong></p>
<img src="/2022/07/15/%E5%86%B2%EF%BC%81/image-20220826112318178.png" class title="image-20220826112318178" loading="lazy">

<p><strong>TCP</strong></p>
<blockquote>
<p><strong>重传时机</strong>：收到3个冗余ACK（一个初始+三个冗余共四个相同的ACK）快速重传or计时器超时——都只重传base处的报文段（因此也只有一个计时器）</p>
<p><strong>接收方</strong>：累计确认，ACK(n)表示n以前的全部确认</p>
</blockquote>
<p><strong>流量控制</strong>和<strong>拥塞控制</strong>：</p>
<img src="/2022/07/15/%E5%86%B2%EF%BC%81/image-20220826160421231.png" class title="image-20220826160421231" loading="lazy"></li>
<li><p>三次握手与四次挥手：</p>
<ul>
<li><p>建立连接三次握手：</p>
<img src="https://img-blog.csdnimg.cn/20190414101321191.png" alt="img" style="zoom: 50%;" loading="lazy"></li>
<li><p>关闭连接四次挥手：</p>
<img src="https://img-blog.csdnimg.cn/2019041418290822.png" alt="img" style="zoom:50%;" loading="lazy"></li>
</ul>
</li>
</ul>
<h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><ul>
<li>网络层服务：<strong>转发和路由</strong></li>
<li>虚电路网络和数据报网络</li>
<li>IP协议<ul>
<li>IP地址<ul>
<li>共分为ABCDE五类，但只有ABC分为网络号和主机号</li>
<li>全0和全1一般不能用</li>
<li>私有IP地址：<img src="/2022/07/15/%E5%86%B2%EF%BC%81/image-20220911185915020.png" alt="image-20220911185915020" style="zoom: 67%;" loading="lazy"></li>
</ul>
</li>
<li>ICMP协议（互联网控制报文协议）</li>
</ul>
</li>
<li>路由协议：RIP、OSPF、BGP</li>
</ul>
<h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><ul>
<li><p>数据链路层提供的服务：</p>
<img src="/2022/07/15/%E5%86%B2%EF%BC%81/image-20220911182123606.png" alt="image-20220911182123606" style="zoom:80%;" loading="lazy"></li>
<li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_53144843/article/details/121293811">MAC多路访问控制协议</a>：决定结点如何共享信道，即决策结点何时可以传输数据</p>
<p><img src="https://img-blog.csdnimg.cn/add52a60dd1b4b3cae5adcd235f351d0.png" alt="在这里插入图片描述" loading="lazy"></p>
</li>
<li><p>MAC地址</p>
<p>IP地址（IPv4：32位；IPv6:128位），MAC地址（48位）</p>
<p>MAC地址固化在网卡的ROM中</p>
<img src="/2022/07/15/%E5%86%B2%EF%BC%81/image-20220911175911332.png" alt="image-20220911175911332" style="zoom: 67%;" loading="lazy"> </li>
<li><p>ARP协议（Address Resolution Protocol）：将已知IP地址转换为MAC地址</p>
<p>【是跨越链路层和网络层边界的协议】</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/JAZZSOLDIER/article/details/52635744">ARP协议在同网段及跨网段下的工作原理</a></p>
<p><img src="https://img-blog.csdnimg.cn/28f9a7a0e6b74623928abd0f888075e5.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAd2FuX25hbg==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="ARP1" style="zoom:50%;" loading="lazy"><img src="https://img-blog.csdnimg.cn/a4da6dc758cd48708db11b4eae230f56.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAd2FuX25hbg==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="ARP2" style="zoom: 50%;" loading="lazy"></p>
</li>
<li><p>关于ARP寻址和MAC地址存在必要性的问题</p>
<p>IP地址更像用来 源 和 目的 之间端到端寻址，整个过程几乎不改变，少数改变的情况：从内网出去NAT可能要改变源IP地址</p>
<p>而MAC地址：在不断地经过路由器转发的过程中，被用来表示下一个阶段性目标，在到达目的主机之前，每走一段路转发一次，就需要更改</p>
</li>
</ul>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><blockquote>
<p>Q:能不能直接在应用层把数据交给网络层？</p>
<p>A:在应用层直接把数据交给网络层，等于失去了复用分用功能，不会在ip数据报前面封装目的端口号，在分用的时候就不知道该将报文交付给哪个应用进程。除非在应用层完成原本在运输层应该完成的任务。</p>
<img src="/2022/07/15/%E5%86%B2%EF%BC%81/image-20220911171652186.png" alt="image-20220911171652186" style="zoom:67%;" loading="lazy">

<hr>
<p>Q:RIP协议与OSPF协议？BGP协议？</p>
<p><u>自治系统或自治域（英文：Autonomous system, AS）</u></p>
<p>A:（RIP协议与OSPF协议两者都是AS<strong>内部网关协议</strong>）RIP协议如同他的名字，由于各方面的缺点（如无穷级数问题导致的最多15跳）已经不被使用，更多使用的是OSPF协议。RIP基于Floyd算法，OSPF基于Dijkstra算法。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/2898dc090e1d">两者区别</a><ul>
<li>RIP：每隔30秒，路由器将自己知道的全部信息，即整个路由表发送给<strong>相邻的</strong>路由器。</li>
<li>OSPF：使用<strong>洪泛法</strong>向本自治系统的<strong>其他所有路由器</strong>发送信息</li>
</ul>
</li>
</ul>
<p>BGP：边界网关协议（属于<strong>外部网关协议</strong>）</p>
<img src="https://img-blog.csdnimg.cn/7be01f4ccb4c4227a2121c7c31721470.png" style="zoom:58%;" loading="lazy">

<p>应用层：HTTP、DNS、SMTP、RIP、BGP</p>
<p>传输层：TCP、UDP、OSPF（基于IP）</p>
<p>网络层：IP、ARP、ICMP</p>
<hr>
<p>Q:域名解析过程：</p>
<p>A:<img src="/2022/07/15/%E5%86%B2%EF%BC%81/image-20220911183110970.png" class title="image-20220911183110970" loading="lazy"></p>
<hr>
<p>Q:<strong>Web页面请求历程</strong></p>
<p>A:<a target="_blank" rel="noopener" href="https://blog.csdn.net/w_bu_neng_ku/article/details/79889156">详细总结：Web页面请求的完整历程</a></p>
<hr>
<p>DNS映射：域名-IP地址</p>
<p>ARP映射：IP地址-MAC地址</p>
<p>上述两个映射都有缓存</p>
<hr>
<p>Q:HTTP与HTTPS的区别</p>
<p>A:<img src="/2022/07/15/%E5%86%B2%EF%BC%81/image-20220911185601949.png" class title="image-20220911185601949" loading="lazy"></p>
</blockquote>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><ul>
<li><p><strong>ACID特性</strong></p>
<p><strong>ACID</strong>，是指<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F">数据库管理系统</a>（<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/DBMS">DBMS</a>）在写入或更新资料的过程中，为保证<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1">事务</a>（transaction）是正确可靠的，所必须具备的四个特性：<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E5%8E%9F%E5%AD%90%E6%80%A7&action=edit&redlink=1">原子性</a>（atomicity，或称不可分割性）、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%B8%80%E8%87%B4%E6%80%A7_(%E6%95%B0%E6%8D%AE%E5%BA%93)">一致性</a>（consistency）、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%9A%94%E9%9B%A2%E6%80%A7">隔离性</a>（isolation，又称独立性）、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%8C%81%E4%B9%85%E6%80%A7">持久性</a>（durability）。</p>
<img src="/2022/07/15/%E5%86%B2%EF%BC%81/image-20220820162711917.png" class title="image-20220820162711917" loading="lazy">

<p>在数据库系统中，一个<strong>事务</strong>是指：由一系列数据库操作组成的一个完整的逻辑过程。例如银行转帐，从原账户扣除金额，以及向目标账户添加金额，这两个数据库操作的总和，构成一个完整的逻辑过程，不可拆分。这个过程被称为一个事务，具有ACID特性。</p>
</li>
<li><p>概念模型：E-R模型</p>
<p>逻辑模型：层次模型、网状模型、<strong>关系模型</strong>（基于此的数据库也成为<u>关系数据库</u>）</p>
</li>
<li><p>三级模式与两级映象</p>
<ul>
<li><p>三级模式：</p>
<img src="/2022/07/15/%E5%86%B2%EF%BC%81/image-20220820183420206.png" class title="image-20220820183420206" loading="lazy">

<img src="/2022/07/15/%E5%86%B2%EF%BC%81/image-20220531152151227.png" alt="image-20220531152151227" style="zoom:50%;" loading="lazy"></li>
<li><p>两级映象：</p>
<img src="/2022/07/15/%E5%86%B2%EF%BC%81/image-20220820183258815.png" class title="image-20220820183258815" loading="lazy"></li>
</ul>
</li>
<li><p><strong>ER模型转换为关系模式</strong>：</p>
<img src="/2022/07/15/%E5%86%B2%EF%BC%81/image-20220820183638023.png" class title="image-20220820183638023" loading="lazy"></li>
<li><p><strong>数据库范式</strong>：</p>
<p><img src="https://img-blog.csdnimg.cn/20190414095710259.png" alt="关系" loading="lazy"></p>
<p><strong>1NF</strong>：属性不可分</p>
<p><strong>2NF</strong>：满足1NF，每个<strong>非主属性</strong>必须<strong>完全函数依赖</strong>于任何一个<strong>候选码</strong>（<u>不存在非主属性对候选码的部分函数依赖，即不能只依赖于候选码的一部分</u>）</p>
<p><strong>3NF</strong>：满足2NF，<u>不存在<strong>非主属性</strong>对候选码的<strong>传递函数依赖</strong></u></p>
<p><strong>BCNF</strong>：满足3NF，<u>每一个非平凡函数依赖<strong>左部</strong>一定<strong>包含</strong>一个候选码</u>（候选码可以由多个主属性组成）</p>
<p>4NF不提了</p>
</li>
<li><p>视图：（对应三级模式中的外模式）</p>
<p><strong>视图是虚拟表，本身不存储数据，而是按照指定的方式进行查询。</strong></p>
<p>当对通过视图看到的数据进行修改时，相应的基本表的数据也要发生变化。同时，若基本表的数据发生变化，则这种变化也可以自动地反映到视图中。</p>
</li>
<li><p><strong>关系模式和关系</strong>：</p>
<p>“关系模式”和“关系”的区别，类似于面向对象程序设计中”类“与”对象“的区别。</p>
<p>”关系“是”关系模式“的一个实例，你<u>可以把”关系”理解为一张带数据的表，而“关系模式”是这张数据表的表结构</u></p>
<p>关系模式是静态的，关系是动态的</p>
<ul>
<li><strong>关系模式</strong>是二维表的表头属性等，即一个二维表的主要架构。由于二维表的属性名一般不会修改，所以呈现出静态。</li>
<li><strong>关系</strong>是一张二维表的具体数据，除去表头外各数据间的联系。由于二维表中是数据会时常修改，所以呈现出动态。</li>
</ul>
</li>
<li><p><strong>数据库增删改查</strong></p>
<p>创建表：create</p>
<p>删除表：drop（删除某个列或某个约束时要结合alter使用）</p>
<p>约束：<code>constraint PK_student PRIMARY KEY(sno, cno),</code></p>
<p>修改表结构：</p>
<ul>
<li><p>```SQL<br>ALTER TABLE table_name<br>ADD column_name datatype<br>/DROP COLUMN column_name<br>/ALTER COLUMN column_name datatype</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">查询：select ··· from ··· where</span><br><span class="line"></span><br><span class="line">- join/in</span><br><span class="line">- group by</span><br><span class="line">- having</span><br><span class="line">- exists</span><br><span class="line"></span><br><span class="line">表内容</span><br><span class="line"></span><br><span class="line">- 增：insert into</span><br><span class="line"></span><br><span class="line">  ```SQL</span><br><span class="line">  Insert Into &lt;表名&gt;[(&lt;属性列&gt;[&#123;,&lt;属性列&gt;&#125;])]</span><br><span class="line">  	Values(&lt;值&gt;[&#123;,&lt;值&gt;&#125;])</span><br><span class="line">  Insert Into Student</span><br><span class="line">  	Values (‘95020’, ‘陈冬’, ‘IS’, 18)</span><br></pre></td></tr></table></figure></li>
<li><p>删：delete from ··· where</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Delete</span> <span class="keyword">From</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span></span><br><span class="line">	[<span class="keyword">Where</span> <span class="operator">&lt;</span>条件<span class="operator">&gt;</span>]</span><br><span class="line"><span class="keyword">Delete</span> <span class="keyword">From</span> Student</span><br><span class="line">	<span class="keyword">Where</span> Sno<span class="operator">=</span>‘<span class="number">95019</span>’</span><br></pre></td></tr></table></figure></li>
<li><p>改：update ··· set ··· where</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UPDATE table_name</span><br><span class="line"><span class="keyword">SET</span> column1 <span class="operator">=</span> value1, column2 <span class="operator">=</span> value2...., columnN <span class="operator">=</span> valueN</span><br><span class="line"><span class="keyword">WHERE</span> [<span class="keyword">condition</span>];</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>关系的完整性</strong>：</p>
<ul>
<li>实体完整性：<strong>主属性</strong>不能取空值</li>
<li>参照完整性：<strong>外码</strong>在其原本的表中应该有所对应</li>
<li>用户定义的完整性：属性要满足语义要求，例如性别只能是’男’或’女’</li>
</ul>
</li>
<li><p>数据库的<strong>并发控制</strong>：</p>
<ul>
<li><p>丢失更新（并发时一方的更新被覆盖了，像丢失了一样）</p>
<img src="/2022/07/15/%E5%86%B2%EF%BC%81/image-20220628211819822.png" alt="image-20220628211819822" style="zoom:50%;" loading="lazy"></li>
<li><p>读脏（<strong>撤销更改</strong>）</p>
<img src="/2022/07/15/%E5%86%B2%EF%BC%81/image-20220628211847524.png" alt="image-20220628211847524" style="zoom: 50%;" loading="lazy">

<img src="/2022/07/15/%E5%86%B2%EF%BC%81/image-20220628211908776.png" alt="image-20220628211908776" style="zoom:50%;" loading="lazy"></li>
<li><p>不可重复读（<strong>两次读操作结果不一样</strong>）</p>
<img src="/2022/07/15/%E5%86%B2%EF%BC%81/image-20220628211950071.png" alt="image-20220628211950071" style="zoom:50%;" loading="lazy">

<img src="/2022/07/15/%E5%86%B2%EF%BC%81/image-20220628212250572.png" alt="image-20220628212250572" style="zoom:50%;" loading="lazy"></li>
</ul>
</li>
<li><p>两种锁（share和exclusive）</p>
<img src="/2022/07/15/%E5%86%B2%EF%BC%81/image-20220628212657748.png" alt="image-20220628212657748" style="zoom:50%;" loading="lazy"></li>
</ul>
<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><ul>
<li><p>操作系统的特点：</p>
<ul>
<li><p><strong>并发</strong>：指两个或多个事件在同一时间间隔内发生，微观上还是程序在分时地交替执行</p>
<ul>
<li><p>区分并发和并行：</p>
<img src="/2022/07/15/%E5%86%B2%EF%BC%81/image-20220908090846844.png" class title="image-20220908090846844" loading="lazy"></li>
</ul>
</li>
<li><p>共享：指系统中的资源可供内存中多个并发执行的进程共同使用，主要包括两个方式，一种为互斥共享方式，例如如打印机，在一段时间内只允许一个进程访问该资源；另一种为同时访问方式，例如磁盘设备</p>
</li>
<li><p>虚拟: （没有并发性就谈不上虚拟性）是指一个物理上的实体变为若干个逻辑上的对应物，物理实体(前者)是实际存在的，而逻辑上对应物(后者)是用户感受到的</p>
</li>
<li><p>异步：在多道程序环境下，允许多个程序并发的执行，但由于资源有限，进程的执行不是一管到底的，而是走走停停已不可预知的速度向前推进</p>
<ul>
<li>区分同步与异步：<img src="/2022/07/15/%E5%86%B2%EF%BC%81/image-20220908091311359.png" class title="image-20220908091311359" loading="lazy"></li>
</ul>
</li>
</ul>
</li>
<li><p>操作系统的作用：</p>
<ul>
<li><p>操作系统作为用户与硬件系统之间的接口。</p>
</li>
<li><p>操作系统作为资源的管理者。</p>
<img src="/2022/07/15/%E5%86%B2%EF%BC%81/image-20220907165028801.png" alt="image-20220907165028801" style="zoom: 67%;" loading="lazy"></li>
<li><p>操作系统实现了对资源的抽象。</p>
</li>
</ul>
</li>
<li><p>进程与线程：</p>
<ul>
<li><p>进程：</p>
<p>进程是指一个具有独立功能的程序对某个数据集在处理机上的执行过程和分配资源的基本单位。每个进程包含独立的地址空间，进程各自的地址空间是私有的，只有执行自己地址空间中的程序，且只能访问自己地址空间中的数据，相互访问会导致指针的越界错误。</p>
<p>进程是操作系统进行资源分配的基本单位。</p>
</li>
<li><p>线程：</p>
<p>线程是独立调度的基本单位，一个进程中可以有多个线程。</p>
<p>线程是一个“轻量级进程”，是一个基本的 CPU 执行单元，也是程序执行流的最小单元。它可以减小程序在并发执行时所付出的时空开销，提高操作系统的并发性能。</p>
<p>线程共享进程拥有的全部资源，它不拥有系统资源，但是它可以访问进程所拥有的系统资源。线程没有自己独立的地址空间，它共享它所属的进程的空间。</p>
</li>
<li><p>进程与线程的区别</p>
<img src="/2022/07/15/%E5%86%B2%EF%BC%81/image-20220907223019664.png" class title="image-20220907223019664" loading="lazy">

<p><strong>引入线程的目的是为了提高系统的并发性，这是因为，同一进程内的不同线程切换不会引起进程切换，从而避免系统调用，减少了系统开销。</strong> </p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zgq0/p/8780893.html"><strong>进程间</strong>的通信方式</a>（InterProcess Communication）：</p>
<p>记下面的5种（下面的管道是匿名管道，FIFO是实名管道）</p>
<p>1.管道：速度慢，容量有限，只有父子进程能通讯   </p>
<p>2.FIFO：任何进程间都能通讯，但速度慢   </p>
<p>3.消息队列：容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题   </p>
<p>4.信号量：不能传递复杂消息，只能用来同步   </p>
<p>5.共享内存区：能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了同一进程内的一块内存</p>
<img src="/2022/07/15/%E5%86%B2%EF%BC%81/image-20220918211341161.png" class title="image-20220918211341161" loading="lazy"></li>
<li><p>进程的状态：<strong>阻塞→就绪→运行</strong></p>
<img src="/2022/07/15/%E5%86%B2%EF%BC%81/image-20220908092425614.png" class title="image-20220908092425614" loading="lazy"></li>
<li><p>操作系统进程调度策略：</p>
<p><strong>FCFS(先来先服务)，优先级，时间片轮转，多级反馈</strong></p>
<img src="/2022/07/15/%E5%86%B2%EF%BC%81/image-20220908101841943.png" class title="image-20220908101841943" loading="lazy"></li>
<li><p>线程同步的方式：<u>互斥量-信号量-事件信号</u></p>
<img src="/2022/07/15/%E5%86%B2%EF%BC%81/image-20220908102301715.png" alt="image-20220908102301715" style="zoom:67%;" loading="lazy"></li>
</ul>
</li>
<li><p>临界资源与临界区</p>
<p>临界资源即<strong>一次仅允许一个进程使用的资源</strong>，临界区即对临界资源进行访问的代码。为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。</p>
</li>
<li><h4 id="管程"><a href="#管程" class="headerlink" title="管程"></a><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%AE%A1%E7%A8%8B/10503922">管程</a></h4><p>管程在功能上和信号量及PV操作类似，属于一种进程同步互斥工具，但是具有与信号量及PV操作不同的属性。</p>
<p>管程是由局部于自己的若干公共变量及其说明和所有访问这些公共变量的过程所组成的软件模块。</p>
<p>组成部分<br>1）局部于管程的共享变量；<br>2）对数据结构进行操作的一组过程；<br>3）对局部于管程的数据进行初始化的语句。</p>
</li>
<li><p>死锁：</p>
<ul>
<li><p>什么是死锁：</p>
<p>死锁是指多个进程运行过程中，因为争夺资源而造成的一种僵局，如果没有外力推进，那么处于僵局中的进程就无法继续执行。</p>
</li>
<li><p>死锁产生的四个必要条件：</p>
<img src="/2022/07/15/%E5%86%B2%EF%BC%81/image-20220908091630233.png" class title="image-20220908091630233" loading="lazy"></li>
<li><p>预防/避免死锁：</p>
<p>【避免死锁】在资源的动态分配中，防止系统进入不安全的状态，例如<strong>银行家算法</strong>。</p>
<ul>
<li><p>**<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_33414271/article/details/80245715">银行家算法</a>**：</p>
<blockquote>
<img src="/2022/07/15/%E5%86%B2%EF%BC%81/image-20220908161117663.png" class title="image-20220908161117663" loading="lazy">
</blockquote>
<p>一个例子：左图是初始条件，右图是解法，Work表示当前剩余资源数量，Allocation表示已经分配的资源数量，Need表示还需要的资源数量</p>
<p><img src="https://img-blog.csdn.net/20180508210408944" alt="这里写图片描述" style="zoom:67%;" loading="lazy"><img src="https://img-blog.csdn.net/20180508210518867" alt="这里写图片描述" style="zoom:67%;" loading="lazy"></p>
</li>
</ul>
<p>【解除死锁】将系统从死锁中解脱出来，一般是<strong>撤销进程</strong>或<strong>剥夺资源</strong>。</p>
<p>【预防死锁】<strong>破坏产生死锁的四个必要条件</strong>：互斥、不可剥夺、请求与保持、循环等待</p>
<img src="/2022/07/15/%E5%86%B2%EF%BC%81/image-20220908092113399.png" class title="image-20220908092113399" loading="lazy">

<p>（破坏循环等待是给资源编号，所有进程都只能按顺序申请资源）</p>
<p>【检测死锁】</p>
<p>若每种资源只有一个，则资源分配图中出现环路是死锁的充分必要条件</p>
<p>若每种资源有多个，那么此状态的<u>进程-资源分配图</u>是<u>不可完全简化</u>的是死锁的充分必要条件</p>
</li>
</ul>
</li>
<li><p>快表：</p>
<p>分页系统中内存数据需要两次的内存访问（一次是从内存中访问页表，找到物理块号，另一次是根据第一次得到的物理地址访问内存取出数据），引入快表机制，当需要访问内存数据，首先将页号在快表中查询，若找到则读取，找不到访问页表，再写入快表。当页表过多，需要较大的连续内存空间，这时采用多级页表。</p>
</li>
<li><p><strong>虚拟内存</strong>：允许将一个作业分多次调入内存。可以用分页式、分段式、段页式存储管理来实现。</p>
<p>从逻辑上扩充内存容量。基于<strong>局部性原理</strong>，在程序装入时，可以将程序的一部分装入内存，而将其余部分留在外存，就可以启动程序执行。在程序执行过程中，当要访问的信息不在内存中，由操作系统将所需要的部分调入内存，然后继续执行。操作系统将暂时不用的内容换出到外存上，从而腾出空间来放调入内存的信息。系统好像为用户提供一个比实际内存大得多的存储器，称为虚拟存储器。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41453285/article/details/107827460">分页和分段的区别</a>：</p>
<img src="/2022/07/15/%E5%86%B2%EF%BC%81/image-20220908150609272.png" alt="image-20220908150609272" style="zoom:67%;" loading="lazy">

<blockquote>
<p>段提供二维地址空间，因为分段每段长度不同，需要段码+段内地址来确定具体位置，而分页存储由于页面大小固定，所以只需要一个物理地址即可计算出页码+页内地址</p>
<p>各自的好处：页是信息的物理单位，分页是为实现离散分配方式，<strong>以消减内存的外零头，提高内存的利用率</strong>。段则是信息的逻辑单位，它含有一组其意义相对完整的信息。分段的目的是为了<strong>能更好地满足用户的需要</strong></p>
</blockquote>
<ul>
<li><p>页面置换算法：</p>
<img src="/2022/07/15/%E5%86%B2%EF%BC%81/image-20220908153317026.png" class title="image-20220908153317026" loading="lazy"></li>
</ul>
</li>
<li><p>哲学家进餐问题（利用信号量控制最多4个哲学家进程并发执行）</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Sunflowerfiona/article/details/52756819">哲学家就餐问题的分析与解决方案</a></p>
</li>
<li><p>缓冲区溢出：</p>
<p>缓冲区溢出是指当 <strong>计算机 向缓冲区内填充数据位数时超过了缓冲区本身的容量，溢出的数据覆盖在合法数据上</strong>。</p>
<ul>
<li><p>如何避免缓冲区溢出（第三条可以由操作系统执行）</p>
<img src="/2022/07/15/%E5%86%B2%EF%BC%81/image-20220908155205564.png" alt="image-20220908155205564" style="zoom: 80%;" loading="lazy">

<p>5、使堆栈向高地址方向增长：栈是从高址向低址增长的，而缓冲区是从低址向高址填充的，所以缓冲区可能会覆盖掉栈中的内容</p>
<p>使用的机器堆栈压入数据时向高地址方向前进，那么无论缓冲区如何溢出，都不可能覆盖低地址处的函数返回地址指针，也就避免了缓冲区溢出攻击。但是这种方法仍然无法防范利用堆和静态数据段的缓冲区进行溢出的攻击。</p>
<img src="https://img-blog.csdnimg.cn/cb718bd44a2f433c9d93b7ccb595ff04.png" alt="img" style="zoom: 67%;" loading="lazy"></li>
</ul>
</li>
<li><p>中断、系统调用、库函数</p>
<p>【<strong>中断和系统调用的关系</strong>在于】当进程发出系统调用申请的时候，会产生一个软中断</p>
<img src="/2022/07/15/%E5%86%B2%EF%BC%81/image-20220908160330976.png" class title="image-20220908160330976" loading="lazy"></li>
<li><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/3c2b79af130b">磁盘调度算法</a>：</p>
<p>先来先服务算法（FCFS）</p>
<p>最短寻找时间优先（SSTF）</p>
<p>扫描算法（SCAN）</p>
<p>循环扫描算法（C-SCAN）</p>
<img src="https://upload-images.jianshu.io/upload_images/18464438-51a047178ff21028.png" alt="img" style="zoom:67%;" loading="lazy"></li>
</ul>
<h1 id="材料"><a href="#材料" class="headerlink" title="材料"></a>材料</h1><ul>
<li><input disabled type="checkbox"> <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/421144026">个人陈述</a></li>
<li><input disabled type="checkbox"> </li>
</ul>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><ul>
<li><p>英语常见问答</p>
<img src="/2022/07/15/%E5%86%B2%EF%BC%81/image-20220715193229538.png" alt="image-20220715193229538" style="zoom:25%;" loading="lazy"></li>
</ul>
</div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>wan_nan</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="https://wan-nan.github.io/2022/07/15/%E5%86%B2%EF%BC%81/" title="冲！">https://wan-nan.github.io/2022/07/15/%E5%86%B2%EF%BC%81/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本博客所有文章除特别声明外，均默认采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><svg class="icon"><use xlink:href="#icon-creative-commons-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-by-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-nc-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-sa-line"></use></svg></a> 许可协议。</li></ul></section></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/2022/07/21/731.%E6%88%91%E7%9A%84%E6%97%A5%E7%A8%8B%E5%AE%89%E6%8E%92%E8%A1%A8%20II%EF%BC%88%E7%BA%BF%E6%AE%B5%E6%A0%91%EF%BC%89/" rel="prev" title="731.我的日程安排表II（初探线段树）"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-left-s-line"></use></svg><span class="post-nav-text">731.我的日程安排表II（初探线段树）</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/2022/07/14/745.%E5%89%8D%E7%BC%80%E5%92%8C%E5%90%8E%E7%BC%80%E6%90%9C%E7%B4%A2%EF%BC%88Trie%E5%86%99%E6%B3%95%EF%BC%89/" rel="next" title="745.前缀和后缀搜索（Trie写法）"><span class="post-nav-text">745.前缀和后缀搜索（Trie写法）</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-right-s-line"></use></svg></a></div></div></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2021 – 2022 </span><span class="with-love" id="animate"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-cloud-line"></use></svg></span><span class="author"> wan_nan</span></div><div class="live_time"><span>本博客已悄悄运行</span><span id="display_live_time"></span><span class="moe-text">(●'◡'●)</span><script>function blog_live_time() {
  setTimeout(blog_live_time, 1000);
  const start = new Date('2021-07-03T00:00:00');
  const now = new Date();
  const timeDiff = (now.getTime() - start.getTime());
  const msPerMinute = 60 * 1000;
  const msPerHour = 60 * msPerMinute;
  const msPerDay = 24 * msPerHour;
  const passDay = Math.floor(timeDiff / msPerDay);
  const passHour = Math.floor((timeDiff % msPerDay) / 60 / 60 / 1000);
  const passMinute = Math.floor((timeDiff % msPerHour) / 60 / 1000);
  const passSecond = Math.floor((timeDiff % msPerMinute) / 1000);
  display_live_time.innerHTML = " " + passDay + " 天 " + passHour + " 小时 " + passMinute + " 分 " + passSecond + " 秒";
}
blog_live_time();
</script></div><div id="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv" title="总访客量"><span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-user-line"></use></svg></span><span id="busuanzi_value_site_uv"></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv" title="总访问量"><span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-eye-line"></use></svg></span><span id="busuanzi_value_site_pv"></span></span></div></footer><a class="hty-icon-button" id="back-to-top" aria-label="back-to-top" href="#"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-up-s-line"></use></svg><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#0078E7" stroke-width="2" stroke-linecap="round"></circle></svg></a><div class="aplayer no-destroy" id="aplayer" data-id="308168565" data-server="netease" data-type="playlist" data-fixed="true" data-theme="#0078E7" data-loop="all" data-order="list" data-preload="auto" data-volume="0.7" data-mutex data-lrctype="0" data-listmaxheight="340px" data-storagename="metingjs"></div></div></body></html>